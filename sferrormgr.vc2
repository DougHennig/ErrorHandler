*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="sferrormgr.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS sferrormessage AS form 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="edtMessage" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdCancel" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdDebug" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdContinue" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdRetry" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdQuit" UniqueID="" Timestamp="" />

	#INCLUDE "sfctrls.h"
	*<DefinedPropArrayMethod>
		*p: cchoice		&& The choice the user made
		*p: oerrormgr		&& A reference to an SFErrorMgr object
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	AllowOutput = .F.
	AlwaysOnTop = .T.
	AutoCenter = .T.
	BorderStyle = 2
	Caption = "Error"
	cchoice = 		&& The choice the user made
	Closable = .F.
	Desktop = .T.
	DoCreate = .T.
	Height = 254
	MaxButton = .F.
	MinButton = .F.
	Name = "sferrormessage"
	oerrormgr = NULL		&& A reference to an SFErrorMgr object
	ShowWindow = 1
	Width = 461
	WindowType = 1
	_memberdata = <VFPData>
		<memberdata name="cchoice" display="cChoice"/>
		<memberdata name="oerrormgr" display="oErrorMgr"/>
		</VFPData>		&& XML Metadata for customizable properties

	ADD OBJECT 'cmdCancel' AS commandbutton WITH ;
		Caption = "Cancel", ;
		FontName = "Segoe UI", ;
		Height = 27, ;
		Left = 10, ;
		Name = "cmdCancel", ;
		Top = 220, ;
		Width = 84
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdContinue' AS commandbutton WITH ;
		Caption = "Continue", ;
		FontName = "Segoe UI", ;
		Height = 27, ;
		Left = 190, ;
		Name = "cmdContinue", ;
		Top = 220, ;
		Width = 84
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdDebug' AS commandbutton WITH ;
		Caption = "Debug", ;
		FontName = "Segoe UI", ;
		Height = 27, ;
		Left = 100, ;
		Name = "cmdDebug", ;
		Top = 220, ;
		Width = 84
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdQuit' AS commandbutton WITH ;
		Caption = "Quit", ;
		FontName = "Segoe UI", ;
		Height = 27, ;
		Left = 370, ;
		Name = "cmdQuit", ;
		Top = 220, ;
		Width = 84
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdRetry' AS commandbutton WITH ;
		Caption = "Retry", ;
		FontName = "Segoe UI", ;
		Height = 27, ;
		Left = 280, ;
		Name = "cmdRetry", ;
		Top = 220, ;
		Width = 84
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'edtMessage' AS label WITH ;
		BackStyle = 0, ;
		Caption = "Error message", ;
		FontName = "Segoe UI", ;
		Height = 200, ;
		Left = 10, ;
		Name = "edtMessage", ;
		Top = 10, ;
		Width = 440, ;
		WordWrap = .T.
		*< END OBJECT: BaseClass="label" />
	
	PROCEDURE Destroy
		This.oErrorMgr = NULL
		
	ENDPROC

	PROCEDURE Init
		lparameters toErrorMgr
		with This
		
		* Save a reference to the error manager that called us.
		
			.oErrorMgr = toErrorMgr
		
		* Grab the screen's or active form's icon.
		
			do case
				case not empty(.Icon)
				case type('_screen.ActiveForm.Name') = 'C' and ;
					pemstatus(_screen.ActiveForm, 'Icon', 5) and ;
					not empty(nvl(_screen.ActiveForm.Icon, ''))
					.Icon = _screen.ActiveForm.Icon
				otherwise
					.Icon = _screen.Icon
			endcase
		endwith
		
	ENDPROC

	PROCEDURE Show
		lparameters tnStyle
		with This
			.cmdCancel.Enabled   = .oErrorMgr.lCanCancel
			.cmdDebug.Enabled    = .oErrorMgr.lShowDebug
			.cmdContinue.Enabled = .oErrorMgr.lCanContinue
			.cmdRetry.Enabled    = .oErrorMgr.lCanContinue
			.Caption             = .oErrorMgr.cTitle
			.edtMessage.Caption  = left(strtran(.oErrorMgr.cMessage, ccTAB, space(4)), ;
				254)
		endwith
		dodefault(tnStyle)
		
	ENDPROC

	PROCEDURE cmdCancel.Click
		Thisform.cChoice = This.Caption
		Thisform.Hide()
		
	ENDPROC

	PROCEDURE cmdCancel.Init
		This.Caption = ccMSG_CANCEL
		dodefault()
		
	ENDPROC

	PROCEDURE cmdContinue.Click
		Thisform.cChoice = This.Caption
		Thisform.Hide()
		
	ENDPROC

	PROCEDURE cmdContinue.Init
		This.Caption = ccMSG_CONTINUE
		dodefault()
		
	ENDPROC

	PROCEDURE cmdDebug.Click
		Thisform.cChoice = This.Caption
		Thisform.Hide()
		
	ENDPROC

	PROCEDURE cmdDebug.Init
		This.Caption = ccMSG_DEBUG
		dodefault()
		
	ENDPROC

	PROCEDURE cmdQuit.Click
		Thisform.cChoice = This.Caption
		Thisform.Hide()
		
	ENDPROC

	PROCEDURE cmdQuit.Init
		This.Caption = ccMSG_QUIT
		dodefault()
		
	ENDPROC

	PROCEDURE cmdRetry.Click
		Thisform.cChoice = This.Caption
		Thisform.Hide()
		
	ENDPROC

	PROCEDURE cmdRetry.Init
		This.Caption = ccMSG_RETRY
		dodefault()
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sferrormessagedialog AS form 		&& A modal dialog to display error messages
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="shpSendReport" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblMessage6" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblMessage4" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="shpRecover" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdSave" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblMessage3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdContinue" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdHelp" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdQuit" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblMessage5" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblComments" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Image1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblMessage1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblMessage2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="edtComments" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdEmail" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblSenderName" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtSenderName" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblSenderEmail" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtSenderEmail" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblSendReport" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblRecover" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="tmrFocus" UniqueID="" Timestamp="" />

	#INCLUDE "sferrormgr.h"
	*<DefinedPropArrayMethod>
		*m: sendmessage		&& Sends the error message
		*p: cchoice		&& The choice made by the user
		*p: ccontact		&& The contact's name
		*p: cemail		&& The contact's email address
		*p: lsent		&& .T. if a ticket was created or email sent
		*p: oerrormgr		&& A reference to an SFErrorMgr object
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	AllowOutput = .F.
	AlwaysOnTop = .T.
	AutoCenter = .T.
	BackColor = 255,255,255
	BorderStyle = 2
	Caption = "Error"
	cchoice = 		&& The choice made by the user
	ccontact = 		&& The contact's name
	cemail = 		&& The contact's email address
	Closable = .F.
	ControlBox = .F.
	Desktop = .T.
	DoCreate = .T.
	Height = 540
	lsent = .F.		&& .T. if a ticket was created or email sent
	MaxButton = .F.
	MinButton = .F.
	Name = "sferrormessagedialog"
	oerrormgr = .NULL.		&& A reference to an SFErrorMgr object
	ShowWindow = 1
	Width = 475
	WindowType = 1
	_memberdata = <VFPData>
		<memberdata name="cchoice" type="property" display="cChoice"/>
		<memberdata name="ccontact" type="property" display="cContact"/>
		<memberdata name="cemail" type="property" display="cEmail"/>
		<memberdata name="oerrormgr" type="property" display="oErrorMgr"/>
		<memberdata name="sendmessage" type="method" display="SendMessage"/>
		<memberdata name="lsent" display="lSent"/>
		</VFPData>		&& XML Metadata for customizable properties

	ADD OBJECT 'cmdContinue' AS commandbutton WITH ;
		Caption = "\<Continue", ;
		FontName = "Segoe UI", ;
		Height = 27, ;
		Left = 285, ;
		Name = "cmdContinue", ;
		TabIndex = 18, ;
		Top = 490, ;
		Width = 84, ;
		ZOrderSet = 7
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdEmail' AS commandbutton WITH ;
		Caption = "\<Send", ;
		FontName = "Segoe UI", ;
		Height = 27, ;
		Left = 375, ;
		Name = "cmdEmail", ;
		TabIndex = 15, ;
		Top = 315, ;
		Width = 84
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdHelp' AS commandbutton WITH ;
		Caption = "Help", ;
		FontName = "Segoe UI", ;
		Height = 27, ;
		Left = 195, ;
		Name = "cmdHelp", ;
		TabIndex = 17, ;
		Top = 490, ;
		Width = 84, ;
		ZOrderSet = 7
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdQuit' AS commandbutton WITH ;
		Caption = "\<Quit", ;
		FontName = "Segoe UI", ;
		Height = 27, ;
		Left = 375, ;
		Name = "cmdQuit", ;
		TabIndex = 19, ;
		Top = 490, ;
		Width = 84, ;
		ZOrderSet = 8
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdSave' AS commandbutton WITH ;
		Caption = "S\<ave...", ;
		FontName = "Segoe UI", ;
		Height = 27, ;
		Left = 375, ;
		Name = "cmdSave", ;
		TabIndex = 16, ;
		Top = 355, ;
		Width = 84, ;
		ZOrderSet = 4
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'edtComments' AS editbox WITH ;
		FontName = "Segoe UI", ;
		Height = 78, ;
		Left = 20, ;
		Name = "edtComments", ;
		SelectOnEntry = .T., ;
		TabIndex = 10, ;
		Top = 230, ;
		Width = 440, ;
		ZOrderSet = 14
		*< END OBJECT: BaseClass="editbox" />

	ADD OBJECT 'Image1' AS image WITH ;
		Height = 59, ;
		Left = -1, ;
		Name = "Image1", ;
		Picture = errorheader.gif, ;
		Top = -1, ;
		Width = 477, ;
		ZOrderSet = 11
		*< END OBJECT: BaseClass="image" />

	ADD OBJECT 'lblComments' AS label WITH ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "Please enter any \<comments you think would help Technical Support staff:", ;
		FontName = "Segoe UI", ;
		Left = 20, ;
		Name = "lblComments", ;
		TabIndex = 9, ;
		Top = 210, ;
		ZOrderSet = 10
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblMessage1' AS label WITH ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "An unexpected error has occurred.", ;
		FontBold = .T., ;
		FontName = "Segoe UI", ;
		Left = 15, ;
		Name = "lblMessage1", ;
		TabIndex = 1, ;
		Top = 10, ;
		Width = 196, ;
		ZOrderSet = 12
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblMessage2' AS label WITH ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "We apologize for the inconvenience; the trouble is temporary.", ;
		FontName = "Segoe UI", ;
		Left = 15, ;
		Name = "lblMessage2", ;
		TabIndex = 2, ;
		Top = 35, ;
		Width = 327, ;
		ZOrderSet = 13
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblMessage3' AS label WITH ;
		AutoSize = .F., ;
		BackStyle = 0, ;
		Caption = "It is very important to report this error to Technical Support. The error report contains critical information our staff needs to provide you with a resolution to this problem as quickly as possible.", ;
		FontName = "Segoe UI", ;
		Height = 44, ;
		Left = 20, ;
		Name = "lblMessage3", ;
		TabIndex = 4, ;
		Top = 95, ;
		Width = 434, ;
		WordWrap = .T., ;
		ZOrderSet = 6
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblMessage4' AS label WITH ;
		AutoSize = .F., ;
		BackStyle = 0, ;
		Caption = "Please click the Send button to send the error report to Technical Support.", ;
		FontName = "Segoe UI", ;
		Height = 44, ;
		Left = 20, ;
		Name = "lblMessage4", ;
		TabIndex = 11, ;
		Top = 315, ;
		Width = 346, ;
		WordWrap = .T., ;
		ZOrderSet = 2
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblMessage5' AS label WITH ;
		AutoSize = .F., ;
		BackStyle = 0, ;
		Caption = "If you wish to continue working in this application, click Continue. To exit, click Quit.", ;
		FontName = "Segoe UI", ;
		Height = 30, ;
		Left = 15, ;
		Name = "lblMessage5", ;
		TabIndex = 14, ;
		Top = 450, ;
		Width = 434, ;
		WordWrap = .T., ;
		ZOrderSet = 9
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblMessage6' AS label WITH ;
		AutoSize = .F., ;
		BackStyle = 0, ;
		Caption = "If you want to save a copy of the report for your own records, please click Save.", ;
		FontName = "Segoe UI", ;
		Height = 30, ;
		Left = 20, ;
		Name = "lblMessage6", ;
		TabIndex = 12, ;
		Top = 355, ;
		Width = 349, ;
		WordWrap = .T., ;
		ZOrderSet = 1
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblRecover' AS label WITH ;
		AutoSize = .T., ;
		BackColor = 255,255,255, ;
		Caption = " 2. Recovering From the Error ", ;
		FontName = "Segoe UI", ;
		Left = 15, ;
		Name = "lblRecover", ;
		Style = 3, ;
		Top = 425
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblSenderEmail' AS label WITH ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "Your email address", ;
		FontName = "Segoe UI", ;
		Left = 20, ;
		Name = "lblSenderEmail", ;
		TabIndex = 7, ;
		Top = 183, ;
		Visible = .T.
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblSenderName' AS label WITH ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "Your name", ;
		FontName = "Segoe UI", ;
		Left = 20, ;
		Name = "lblSenderName", ;
		TabIndex = 5, ;
		Top = 158, ;
		Visible = .T.
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblSendReport' AS label WITH ;
		AutoSize = .T., ;
		BackColor = 255,255,255, ;
		Caption = " 1. Send Report to Technical Support ", ;
		FontName = "Segoe UI", ;
		Left = 15, ;
		Name = "lblSendReport", ;
		Style = 3, ;
		Top = 70
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'shpRecover' AS shape WITH ;
		BackStyle = 0, ;
		Height = 102, ;
		Left = 5, ;
		Name = "shpRecover", ;
		Style = 3, ;
		Top = 431, ;
		Width = 465
		*< END OBJECT: BaseClass="shape" />

	ADD OBJECT 'shpSendReport' AS shape WITH ;
		BackStyle = 0, ;
		Height = 330, ;
		Left = 5, ;
		Name = "shpSendReport", ;
		Style = 3, ;
		Top = 76, ;
		Width = 465
		*< END OBJECT: BaseClass="shape" />

	ADD OBJECT 'tmrFocus' AS timer WITH ;
		Height = 23, ;
		Interval = 500, ;
		Left = 65, ;
		Name = "tmrFocus", ;
		Top = 495, ;
		Width = 23
		*< END OBJECT: BaseClass="timer" />

	ADD OBJECT 'txtSenderEmail' AS textbox WITH ;
		ControlSource = "Thisform.cEmail", ;
		FontName = "Segoe UI", ;
		Height = 23, ;
		Left = 160, ;
		Name = "txtSenderEmail", ;
		SelectOnEntry = .T., ;
		TabIndex = 8, ;
		Top = 180, ;
		Visible = .T., ;
		Width = 300
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'txtSenderName' AS textbox WITH ;
		ControlSource = "Thisform.cContact", ;
		FontName = "Segoe UI", ;
		Height = 23, ;
		Left = 160, ;
		Name = "txtSenderName", ;
		SelectOnEntry = .T., ;
		TabIndex = 6, ;
		Top = 155, ;
		Visible = .T., ;
		Width = 300
		*< END OBJECT: BaseClass="textbox" />
	
	PROCEDURE Destroy
		This.oErrorMgr = NULL
		
	ENDPROC

	PROCEDURE GotFocus
		* If lblComments is too long, word wrap it.
		
		doevents force
		if This.lblComments.Width > This.lblMessage3.Width
			This.lblComments.AutoSize = .F.
			This.lblComments.WordWrap = .T.
			This.lblComments.Height   = 30
			This.lblComments.Width    = This.lblMessage3.Width
			This.edtComments.Top      = 250
			This.edtComments.Height   = 58
		endif This.lblComments.Width > This.lblMessage3.Width
		This.Refresh()
		
	ENDPROC

	PROCEDURE Init
		lparameters toErrorMgr
		with This
		
		* Save a reference to the error manager that called us.
		
			.oErrorMgr = toErrorMgr
		
		* Grab the screen's or active form's icon.
		
			do case
				case not empty(.Icon)
				case type('_screen.ActiveForm.Name') = 'C' and ;
					pemstatus(_screen.ActiveForm, 'Icon', 5) and ;
					not empty(nvl(_screen.ActiveForm.Icon, ''))
					.Icon = _screen.ActiveForm.Icon
				otherwise
					.Icon = _screen.Icon
			endcase
		endwith
		
	ENDPROC

	PROCEDURE sendmessage		&& Sends the error message
		* Create a support ticket or send an email.
		
		local lcContact, ;
			lcEmail, ;
			lcMessage, ;
			llOK
		with This
			lcContact = alltrim(.cContact)
			lcEmail   = alltrim(.cEmail)
			lcMessage = alltrim(.oErrorMgr.cMessage) + ;
				iif(empty(.edtComments.Value), '', ccCRLF + ccCRLF + 'Comments:' + ;
				ccCRLF + .edtComments.Value)
			llOK = .oErrorMgr.CreateTicketOrEmail(lcMessage, lcEmail, lcContact)
		
		* Display any error that occurred during sending.
		
			if not llOK
				if type('oLocalizer.Name') = 'C'
					lcMessage = oLocalizer.GetLocalizedString('ERR_CANT_EMAIL_ERROR')
				else
					lcMessage = 'The email could not be sent. The message from the ' + ;
						'email server was:'
				endif type('oLocalizer.Name') = 'C'
				messagebox(lcMessage + ccCR + ccCR + .oErrorMgr.cMailErrorMessage, ;
					MB_ICONSTOP, _screen.Caption)
			endif not llOK
		endwith
		return llOK
		
	ENDPROC

	PROCEDURE Show
		lparameters tnStyle
		local llLocalizer, ;
			lnAdjust
		with This
		
		* Set the captions appropriately.
		
			llLocalizer = type('oLocalizer.Name') = 'C'
			.Caption = .oErrorMgr.cTitle
			do case
				case llLocalizer
					.Caption = oLocalizer.GetLocalizedString('STR_ERROR')
					if .oErrorMgr.lCanCancel
						.lblMessage5.Caption = oLocalizer.GetLocalizedString('LBL_CAP_ERROR_4')
					else
						.lblMessage5.Caption = oLocalizer.GetLocalizedString('LBL_CAP_ERROR_7')
					endif .oErrorMgr.lCanCancel
				case not .oErrorMgr.lCanCancel
					.lblMessage5.Caption = 'Due to the nature of the error, the ' + ;
						'application must shut down. Please click Quit.'
			endcase
			do case
				case not .oErrorMgr.lScreenShot
				case llLocalizer
					.lblMessage4.Caption = .lblMessage4.Caption + ' ' + ;
						oLocalizer.GetLocalizedString('LBL_CAP_ERROR_SCREEN_SHOT')
				otherwise
					.lblMessage4.Caption = .lblMessage4.Caption + ;
						' A screen shot is automatically included.'
			endcase
		
		* Hide some controls if necessary.
		
			.cmdContinue.Visible = .oErrorMgr.lCanCancel
			if not .oErrorMgr.lUserCanSaveDialog
				store .F. to .lblMessage6.Visible, .cmdSave.Visible
				lnAdjust = .lblMessage6.Top - .lblMessage4.Top
				store .lblMessage6.Top to .lblMessage4.Top, .cmdEmail.Top
				.edtComments.Height = .edtComments.Height + lnAdjust
			endif not .oErrorMgr.lUserCanSaveDialog
		
		* Set other properties.
		
			.cContact = .oErrorMgr.cContact
			.cEmail   = .oErrorMgr.cEmail
		endwith
		
		* Play the Windows error sound.
		
		if type('oUtility.Name') = 'C'
			oUtility.ErrorSound()
		endif type('oUtility.Name') = 'C'
		dodefault(tnStyle)
		
	ENDPROC

	PROCEDURE cmdContinue.Click
		* Flag that the user wants to cancel the operation that caused the error but
		* stay in the application, then return to the error manager.
		
		Thisform.cChoice = ccMSG_CANCEL
		Thisform.Hide()
		
	ENDPROC

	PROCEDURE cmdContinue.Init
		if type('oLocalizer.Name') = 'C'
			This.Caption = oLocalizer.GetLocalizedString('MSG_CONTINUEHOT')
		endif type('oLocalizer.Name') = 'C'
		dodefault()
		
	ENDPROC

	PROCEDURE cmdEmail.Click
		Thisform.lSent = Thisform.SendMessage()
		This.Enabled   = not Thisform.lSent
		
	ENDPROC

	PROCEDURE cmdEmail.Init
		if type('oLocalizer.Name') = 'C'
			This.Caption = oLocalizer.GetLocalizedString('CMD_CAP_SEND', .T.)
		endif type('oLocalizer.Name') = 'C'
		dodefault()
		
	ENDPROC

	PROCEDURE cmdEmail.Refresh
		* This button is only enabled if we have a mail server to use, we're using
		* MAPI, or we have code for CreateTicket.
		
		local loError
		loError = Thisform.oErrorMgr
		This.Enabled = (not empty(loError.cMailServer) or loError.lMAPI or ;
			pemstatus(loError, 'CreateTicket', 0)) and ;
			not empty(Thisform.txtSenderName.Value) and ;
			not empty(Thisform.txtSenderEmail.Value) and not Thisform.lSent
		
	ENDPROC

	PROCEDURE cmdHelp.Click
		if Thisform.HelpContextID = 0
			help
		else
			help id Thisform.HelpContextID
		endif Thisform.HelpContextID = 0
		
	ENDPROC

	PROCEDURE cmdHelp.Init
		if type('oLocalizer.Name') = 'C'
			This.Caption = oLocalizer.GetLocalizedString('UI_CMD_HELP_LOC')
		endif type('oLocalizer.Name') = 'C'
		dodefault()
		
	ENDPROC

	PROCEDURE cmdQuit.Click
		* Flag that the user wants to quit and return to the error manager.
		
		Thisform.cChoice = ccMSG_QUIT
		Thisform.Hide()
		
	ENDPROC

	PROCEDURE cmdQuit.Init
		if type('oLocalizer.Name') = 'C'
			This.Caption = oLocalizer.GetLocalizedString('MSG_QUITHOT')
		endif type('oLocalizer.Name') = 'C'
		dodefault()
		
	ENDPROC

	PROCEDURE cmdSave.Click
		local lcFileName
		lcFileName = putfile('', 'Error.txt', 'Text file (*.txt)')
		if not empty(lcFileName)
			copy file (Thisform.oErrorMgr.cErrorLogTextFile) to (lcFileName)
			if type('oUtility.Name') = 'C'
				oUtility.ShellExecute(lcFileName)
			else
				lcFileName = '"' + lcFileName + '"'
				try
					declare integer ShellExecute in SHELL32.DLL ;
						integer nWinHandle, ;	&& handle of parent window
						string cOperation, ;	&& operation to perform
						string cFileName, ;		&& filename
						string cParameters, ;	&& parameters for the executable
						string cDirectory, ;	&& default directory
						integer nShowWindow		&& window state
					ShellExecute(0, 'Open', lcFileName, '', '', 1)
				catch
				endtry
			endif type('oUtility.Name') = 'C'
		endif not empty(lcFileName)
		
	ENDPROC

	PROCEDURE cmdSave.Init
		if type('oLocalizer.Name') = 'C'
			This.Caption = oLocalizer.GetLocalizedString('CMD_CAP_SAVE_ERROR')
		endif type('oLocalizer.Name') = 'C'
		dodefault()
		
	ENDPROC

	PROCEDURE lblComments.Init
		if type('oLocalizer.Name') = 'C'
			This.Caption = oLocalizer.GetLocalizedString('LBL_CAP_ERROR_3')
		endif type('oLocalizer.Name') = 'C'
		
	ENDPROC

	PROCEDURE lblMessage1.Init
		if type('oLocalizer.Name') = 'C'
			This.Caption = oLocalizer.GetLocalizedString('LBL_CAP_ERROR_1')
		endif type('oLocalizer.Name') = 'C'
		
	ENDPROC

	PROCEDURE lblMessage2.Init
		if type('oLocalizer.Name') = 'C'
			This.Caption = oLocalizer.GetLocalizedString('LBL_CAP_ERROR_8')
		endif type('oLocalizer.Name') = 'C'
		
	ENDPROC

	PROCEDURE lblMessage3.Init
		if type('oLocalizer.Name') = 'C'
			This.Caption = oLocalizer.GetLocalizedString('LBL_CAP_ERROR_2')
		endif type('oLocalizer.Name') = 'C'
		
	ENDPROC

	PROCEDURE lblMessage4.Init
		if type('oLocalizer.Name') = 'C'
			This.Caption = oLocalizer.GetLocalizedString('LBL_CAP_ERROR_6')
		endif type('oLocalizer.Name') = 'C'
		
	ENDPROC

	PROCEDURE lblMessage6.Init
		if type('oLocalizer.Name') = 'C'
			This.Caption = oLocalizer.GetLocalizedString('LBL_CAP_ERROR_11')
		endif type('oLocalizer.Name') = 'C'
		dodefault()
		
	ENDPROC

	PROCEDURE lblRecover.Init
		if type('oLocalizer.Name') = 'C'
			This.Caption = oLocalizer.GetLocalizedString('LBL_CAP_ERROR_10', , .T.)
		endif type('oLocalizer.Name') = 'C'
		
	ENDPROC

	PROCEDURE lblSenderEmail.Init
		if type('oLocalizer.Name') = 'C'
			This.Caption = oLocalizer.GetLocalizedString('LBL_CAP_EMAIL_ADDRESS')
		endif type('oLocalizer.Name') = 'C'
		
	ENDPROC

	PROCEDURE lblSenderName.Init
		if type('oLocalizer.Name') = 'C'
			This.Caption = oLocalizer.GetLocalizedString('LBL_CAP_EMAIL_CONTACT')
		endif type('oLocalizer.Name') = 'C'
		
	ENDPROC

	PROCEDURE lblSendReport.Init
		if type('oLocalizer.Name') = 'C'
			This.Caption = oLocalizer.GetLocalizedString('LBL_CAP_ERROR_9', , .T.)
		endif type('oLocalizer.Name') = 'C'
		
	ENDPROC

	PROCEDURE tmrFocus.Timer
		* Force us to be the top window if not.
		
		if not wontop() = Thisform.Name
			activate window (Thisform.Name)
			This.Enabled = .F.
		endif not wontop() = Thisform.Name
		
	ENDPROC

	PROCEDURE txtSenderEmail.InteractiveChange
		Thisform.cmdEmail.Refresh()
		
	ENDPROC

	PROCEDURE txtSenderName.InteractiveChange
		Thisform.cmdEmail.Refresh()
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sferrormgr AS custom 		&& An error manager class
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "sferrormgr.h"
	*<DefinedPropArrayMethod>
		*m: about		&& Provides documentation for the class
		*m: checkintry		&& Checks to see if we're in a TRY structure somewhere in the call stack
		*m: cleanupbeforereturn		&& Provides an opportunity to clean things up before RETURN TO is used
		*m: commandshell		&& Displays a pseudo-command window at runtime
		*m: createerrormessage		&& Creates a string describing the error
		*m: createmailobject		&& Creates a mail object
		*m: createticket		&& Creates a support ticket
		*m: createticketoremail		&& Creates a ticket or sends an email
		*m: decrypt		&& Decrypts a string
		*m: diderroroccur		&& An exposed method to return the value of the protected lErrorOccurred.
		*m: displayerror		&& Displays an error message to the user.
		*m: errorhandler		&& The ON ERROR handler.
		*m: getmemvars		&& Creates a list of memvars and their values
		*m: immediateexit		&& Performs an immediate exit
		*m: isreturntooncallstack		&& Determines if the routine specified in cReturnToOnCancel is on the call stack
		*m: logerror		&& Logs the error to a log file.
		*m: reseterror		&& An exposed method to reset the values of the protected lErrorOccurred and public aErrorInfo.
		*m: revertalltables		&& Reverts all cursors in all datasessions
		*m: reverttables		&& Revert cursors in the current datasession
		*m: screenshot		&& Takes a screen shot
		*m: setdialogproperties		&& Sets properties of the error dialog before displaying it
		*m: seterror		&& Sets lErrorOccurred and aErrorInfo to information about the most recent error
		*m: setsuppresserrors		&& An exposed method to set the value of the protected lSuppressErrors.
		*p: calias		&& The selected alias
		*p: cappname		&& The name of the application
		*p: cattachments		&& Attachments for the email or support ticket
		*p: cconsoleclass		&& The class to use for a debugging console at runtime
		*p: cconsolelibrary		&& The library containing the class specified in cConsoleClass
		*p: ccontact		&& The user's display name
		*p: ccurrerror		&& The former ON ERROR handler.
		*p: cdefaultaction		&& The default action to take
		*p: cemail		&& The user's email address
		*p: cemaillogfolder		&& The folder to use for email logging
		*p: cencryptionlibrary		&& The name of the encryption library to use
		*p: cerrorlogfile		&& The name of the table to log errors to
		*p: cerrorlogtextfile		&& The name of the text file to log errors to
		*p: cimagefile		&& The name and path of the image file for the screen shot
		*p: clanguage		&& The language to use for messages
		*p: cmailclass		&& The class to use for emailing
		*p: cmailerrormessage		&& The message of any error from the mail object
		*p: cmaillibrary		&& The library containing the class specified in cMailClass
		*p: cmailserver		&& The mail server
		*p: cmessage		&& The body of the error message
		*p: cmessageclass		&& The name of the class to use to display messages
		*p: cmessagelibrary		&& The library the message class is in
		*p: cpassword		&& The email password
		*p: crecipient		&& The recipient of the email
		*p: cresourcetable		&& The name of the resource table to use
		*p: creturntooncancel		&& The name of the program to return to when Cancel is chosen
		*p: creturntoonquit		&& The name of the program to return to when Quit is chosen
		*p: csenderemail		&& The sender's email address
		*p: csendername		&& The name of the sender
		*p: csubject		&& The subject of the error message
		*p: ctitle		&& The default title for the error message dialog.
		*p: cuser		&& The name of the user.
		*p: cusername		&& The email user name
		*p: cversion		&& The application version number
		*p: lautocreateticket		&& .T. to automatically create a ticket
		*p: lcancancel		&& .T. if the user can "cancel" (that is, stay in the application)
		*p: lcancontinue		&& .T. if the user can "continue" (that is, RETRY or RETURN)
		*p: ldisplayerrors		&& .T. if we're supposed to display errors and get the user's choice
		*p: ldisplayingerrordialog		&& .T. if we're displaying the error dialog
		*p: lemaillogging		&& .T. to do email logging
		*p: lerrorinfosaved		&& .T. if the error information has been saved in aErrorInfo
		*p: lerroroccurred		&& .T. if an error occurred
		*p: lgetmemvars		&& .T. to include memory variables in the error report; .F. if an ActiveX control would cause a buffer overrun
		*p: lgettingmemvars		&& .T. if we're using LIST MEMORY or LIST OBJECTS; an Access method can check it and do nothing if .T.
		*p: lhandlingerror		&& .T. if we're in the process of handling an error
		*p: linsidetry		&& .T. if code was executing inside a TRY structure when the error occurred
		*p: llogtotable		&& .T. if the error should be logged to a table
		*p: lmapi		&& .T. to use MAPI
		*p: lquit		&& .T. if we're quitting (public so other objects can check on the way out)
		*p: lscreenshot		&& .T. to take a screen shot
		*p: lsetonerror		&& .T. to set ON ERROR to point to the ErrorHandler method.
		*p: lshowdebug		&& .T. if "debug" should be an option
		*p: lsuppresserrors		&& If .T., an error isn't logged or displayed
		*p: lticketcreated		&& .T. if a ticket was created
		*p: lusercansavedialog		&& .T. if the user can save the error log
		*p: ndatasession		&& The datasession the error occurred in
		*p: nlasterror		&& The index to the last error that occurred in aErrorInfo
		*p: nmaxerrors		&& The maximum number of entries in aErrorInfo; 0 = no limit
		*p: nreturncode		&& The return code for ExitProcess
		*p: nsecurityoptions		&& The SecureSocketOptions setting to use
		*p: nsmtpport		&& The SMTP port to use
		*p: nthrottleerrorcount		&& The number of errors that have to occur within the timeframe specified in nThrottleThreshold to cause error suppression
		*p: nthrottlethreshold		&& The number of seconds nThrottleErrorCount errors must occur within for error suppression to be enabled
		*p: nthrottlewindow		&& How long to wait when error throttling before errors suppression is disabled
		*p: tthrottletime		&& When error suppression started
		*a: aerrorinfo[1,0]		&& An array containing error information; see the SetError method documentation for the structure of this array.
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	PROTECTED ccurrerror,lerrorinfosaved,lerroroccurred,lsuppresserrors
	calias = 		&& The selected alias
	cappname = 		&& The name of the application
	cattachments = 		&& Attachments for the email or support ticket
	cconsoleclass = SFConsoleForm		&& The class to use for a debugging console at runtime
	cconsolelibrary = SFConsole.vcx		&& The library containing the class specified in cConsoleClass
	ccontact = 		&& The user's display name
	ccurrerror = 		&& The former ON ERROR handler.
	cdefaultaction = 		&& The default action to take
	cemail = 		&& The user's email address
	cemaillogfolder = 		&& The folder to use for email logging
	cencryptionlibrary = VFPEncryption71.fll		&& The name of the encryption library to use
	cerrorlogfile = errorlog.dbf		&& The name of the table to log errors to
	cerrorlogtextfile = 		&& The name of the text file to log errors to
	cimagefile = 		&& The name and path of the image file for the screen shot
	clanguage = English		&& The language to use for messages
	cmailclass = SFMail		&& The class to use for emailing
	cmailerrormessage = 		&& The message of any error from the mail object
	cmaillibrary = SFMail.prg		&& The library containing the class specified in cMailClass
	cmailserver = 		&& The mail server
	cmessage = 		&& The body of the error message
	cmessageclass = SFErrorMessageDialog		&& The name of the class to use to display messages
	cmessagelibrary = SFErrorMgr.vcx		&& The library the message class is in
	cpassword = 		&& The email password
	crecipient = 		&& The recipient of the email
	cresourcetable = Resource.dbf		&& The name of the resource table to use
	creturntooncancel = MASTER		&& The name of the program to return to when Cancel is chosen
	creturntoonquit = MASTER		&& The name of the program to return to when Quit is chosen
	csenderemail = 		&& The sender's email address
	csendername = 		&& The name of the sender
	csubject = 		&& The subject of the error message
	ctitle = Error		&& The default title for the error message dialog.
	cuser = 		&& The name of the user.
	cusername = 		&& The email user name
	cversion = 		&& The application version number
	lautocreateticket = .F.		&& .T. to automatically create a ticket
	lcancancel = .F.		&& .T. if the user can "cancel" (that is, stay in the application)
	lcancontinue = .T.		&& .T. if the user can "continue" (that is, RETRY or RETURN)
	ldisplayerrors = .T.		&& .T. if we're supposed to display errors and get the user's choice
	ldisplayingerrordialog = .F.		&& .T. if we're displaying the error dialog
	lemaillogging = .F.		&& .T. to do email logging
	lerrorinfosaved = .F.		&& .T. if the error information has been saved in aErrorInfo
	lerroroccurred = .F.		&& .T. if an error occurred
	lgetmemvars = .T.		&& .T. to include memory variables in the error report; .F. if an ActiveX control would cause a buffer overrun
	lgettingmemvars = .F.		&& .T. if we're using LIST MEMORY or LIST OBJECTS; an Access method can check it and do nothing if .T.
	lhandlingerror = .F.		&& .T. if we're in the process of handling an error
	linsidetry = .F.		&& .T. if code was executing inside a TRY structure when the error occurred
	llogtotable = .T.		&& .T. if the error should be logged to a table
	lmapi = .F.		&& .T. to use MAPI
	lquit = .F.		&& .T. if we're quitting (public so other objects can check on the way out)
	lscreenshot = .F.		&& .T. to take a screen shot
	lsetonerror = .F.		&& .T. to set ON ERROR to point to the ErrorHandler method.
	lshowdebug = .F.		&& .T. if "debug" should be an option
	lsuppresserrors = .F.		&& If .T., an error isn't logged or displayed
	lticketcreated = .F.		&& .T. if a ticket was created
	lusercansavedialog = .T.		&& .T. if the user can save the error log
	Name = "sferrormgr"
	ndatasession = 0		&& The datasession the error occurred in
	nlasterror = 0		&& The index to the last error that occurred in aErrorInfo
	nmaxerrors = 10		&& The maximum number of entries in aErrorInfo; 0 = no limit
	nreturncode = -1		&& The return code for ExitProcess
	nsecurityoptions = 1		&& The SecureSocketOptions setting to use
	nsmtpport = 25		&& The SMTP port to use
	nthrottleerrorcount = 0		&& The number of errors that have to occur within the timeframe specified in nThrottleThreshold to cause error suppression
	nthrottlethreshold = 0		&& The number of seconds nThrottleErrorCount errors must occur within for error suppression to be enabled
	nthrottlewindow = 0		&& How long to wait when error throttling before errors suppression is disabled
	tthrottletime = /  /     :  :   AM		&& When error suppression started
	Width = 17
	_memberdata = <VFPData>
		<memberdata name="cappname" type="property" display="cAppName"/>
		<memberdata name="ccontact" type="property" display="cContact"/>
		<memberdata name="ccurrerror" type="property" display="cCurrError"/>
		<memberdata name="cdefaultaction" type="property" display="cDefaultAction"/>
		<memberdata name="cemail" type="property" display="cEmail"/>
		<memberdata name="cemaillogfolder" type="property" display="cEmailLogFolder"/>
		<memberdata name="cerrorlogfile" type="property" display="cErrorLogFile"/>
		<memberdata name="checkintry" type="method" display="CheckInTry"/>
		<memberdata name="cimagefile" type="property" display="cImageFile"/>
		<memberdata name="cleanupbeforereturn" type="method" display="CleanupBeforeReturn"/>
		<memberdata name="cmailserver" type="property" display="cMailServer"/>
		<memberdata name="cmessageclass" type="property" display="cMessageClass"/>
		<memberdata name="cmessagelibrary" type="property" display="cMessageLibrary"/>
		<memberdata name="commandshell" type="method" display="CommandShell"/>
		<memberdata name="cpassword" type="property" display="cPassword"/>
		<memberdata name="createerrormessage" type="method" display="CreateErrorMessage"/>
		<memberdata name="createticket" type="method" display="CreateTicket"/>
		<memberdata name="crecipient" type="property" display="cRecipient"/>
		<memberdata name="creturntooncancel" type="property" display="cReturnToOnCancel"/>
		<memberdata name="creturntoonquit" type="property" display="cReturnToOnQuit"/>
		<memberdata name="csenderemail" type="property" display="cSenderEmail"/>
		<memberdata name="csendername" type="property" display="cSenderName"/>
		<memberdata name="ctitle" type="property" display="cTitle"/>
		<memberdata name="cuser" type="property" display="cUser"/>
		<memberdata name="cusername" type="property" display="cUserName"/>
		<memberdata name="cversion" type="property" display="cVersion"/>
		<memberdata name="diderroroccur" type="method" display="DidErrorOccur"/>
		<memberdata name="displayerror" type="method" display="DisplayError"/>
		<memberdata name="errorhandler" type="method" display="ErrorHandler"/>
		<memberdata name="getmemvars" type="method" display="GetMemVars"/>
		<memberdata name="immediateexit" type="method" display="ImmediateExit"/>
		<memberdata name="isreturntooncallstack" type="method" display="IsReturnToOnCallStack"/>
		<memberdata name="lcancancel" type="property" display="lCanCancel"/>
		<memberdata name="lcancontinue" type="property" display="lCanContinue"/>
		<memberdata name="ldisplayerrors" type="property" display="lDisplayErrors"/>
		<memberdata name="ldisplayingerrordialog" type="property" display="lDisplayingErrorDialog"/>
		<memberdata name="lemaillogging" type="property" display="lEmailLogging"/>
		<memberdata name="lerrorinfosaved" type="property" display="lErrorInfoSaved"/>
		<memberdata name="lgetmemvars" type="property" display="lGetMemVars"/>
		<memberdata name="lgettingmemvars" type="property" display="lGettingMemVars"/>
		<memberdata name="linsidetry" type="property" display="lInsideTry"/>
		<memberdata name="llogtotable" type="property" display="lLogToTable"/>
		<memberdata name="lmapi" type="property" display="lMAPI"/>
		<memberdata name="logerror" type="method" display="LogError"/>
		<memberdata name="lquit" type="property" display="lQuit"/>
		<memberdata name="lscreenshot" type="property" display="lScreenShot"/>
		<memberdata name="lsetonerror" type="property" display="lSetOnError"/>
		<memberdata name="lshowdebug" type="property" display="lShowDebug"/>
		<memberdata name="lsuppresserrors" type="property" display="lSuppressErrors"/>
		<memberdata name="nlasterror" type="property" display="nLastError"/>
		<memberdata name="nsecurityoptions" type="property" display="nSecurityOptions"/>
		<memberdata name="nsmtpport" type="property" display="nSMTPPort"/>
		<memberdata name="reseterror" type="method" display="ResetError"/>
		<memberdata name="revertalltables" type="method" display="RevertAllTables"/>
		<memberdata name="reverttables" type="method" display="RevertTables"/>
		<memberdata name="screenshot" type="method" display="ScreenShot"/>
		<memberdata name="setdialogproperties" type="method" display="SetDialogProperties"/>
		<memberdata name="seterror" type="method" display="SetError"/>
		<memberdata name="setsuppresserrors" type="method" display="SetSuppressErrors"/>
		<memberdata name="lerroroccurred" display="lErrorOccurred"/>
		<memberdata name="about" display="About"/>
		<memberdata name="cerrorlogtextfile" display="cErrorLogTextFile"/>
		<memberdata name="cmailclass" display="cMailClass"/>
		<memberdata name="cmaillibrary" display="cMailLibrary"/>
		<memberdata name="lautocreateticket" display="lAutoCreateTicket"/>
		<memberdata name="createticketoremail" display="CreateTicketOrEMail"/>
		<memberdata name="decrypt" display="Decrypt"/>
		<memberdata name="cattachments" display="cAttachments"/>
		<memberdata name="cmailerrormessage" display="cMailErrorMessage"/>
		<memberdata name="nmaxerrors" display="nMaxErrors"/>
		<memberdata name="cmessage" display="cMessage"/>
		<memberdata name="csubject" display="cSubject"/>
		<memberdata name="nthrottlethreshold" display="nThrottleThreshold"/>
		<memberdata name="tthrottletime" display="tThrottleTime"/>
		<memberdata name="nthrottlewindow" display="nThrottleWindow"/>
		<memberdata name="nthrottleerrorcount" display="nThrottleErrorCount"/>
		<memberdata name="aerrorinfo" display="aErrorInfo"/>
		<memberdata name="createmailobject" display="CreateMailObject"/>
		<memberdata name="lusercansavedialog" display="lUserCanSaveDialog"/>
		<memberdata name="lticketcreated" display="lTicketCreated"/>
		<memberdata name="nreturncode" display="nReturnCode"/>
		<memberdata name="calias" display="cAlias"/>
		<memberdata name="lhandlingerror" display="lHandlingError"/>
		<memberdata name="cencryptionlibrary" display="cEncryptionLibrary"/>
		<memberdata name="ndatasession" display="nDataSession"/>
		<memberdata name="clanguage" display="cLanguage"/>
		<memberdata name="cresourcetable" display="cResourceTable"/>
		<memberdata name="cconsoleclass" display="cConsoleClass"/>
		<memberdata name="cconsolelibrary" display="cConsoleLibrary"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE about		&& Provides documentation for the class
		*==============================================================================
		* Class:						SFErrorMgr
		* Based On:						Custom
		* Purpose:						Error handler class
		* Author:						Doug Hennig
		* Last revision:				11/07/2022
		* Include file:					SFErrorMgr.h
		*
		* Changes in "Based On" class properties:
		*	Width:						17
		*
		* Changes in "Based On" class methods:
		*	Init:						initialize properties of the class and if
		*								necessary, save the current ON ERROR handler
		*								and point it to This.ErrorHandler
		*	Destroy:					restore the former ON ERROR handler if
		*								necessary
		*
		* Custom public properties added:
		*	aErrorInfo:					an array containing error information; see the
		*								SetError method documentation for the structure
		*								of this array
		*	cAlias:						the selected alias
		*	cAppName:					the name of the application
		*	cAttachments:				attachments for the email or support ticket
		*	cConsoleClass:				the class to use for a debugging console at
		*								runtime
		*	cConsoleLibrary:			the library containing the class specified in
		*								cConsoleClass
		*	cContact:					the user's display name
		*	cDefaultAction:				the default action to take
		*	cEmail:						the user's email address
		*	cEmailLogFolder:			the folder to use for email logging
		*	cEncryptionLibrary:			the name of the encryption library to use
		*	cErrorLogFile:				the name of the table to log errors to
		*	cErrorLogTextFile:			the name of the text file to log errors to
		*	cImageFile:					the name and path of the image file for the
		*								screen shot
		*	cLanguage:					the language to use for messages
		*	cMailClass:					the class to use for emailing
		*	cMailErrorMessage:			the message of any error from the mail object
		*	cMailLibrary:				the library containing the class specified in
		*								cMailClass
		*	cMailServer:				the mail server
		*	cMessage:					the body of the error message
		*	cMessageClass:				the name of the class to use to display
		*								messages
		*	cMessageLibrary:			the library the message class is in
		*	cPassword:					the email password
		*	cRecipient:					the recipient of the email
		*	cResourceTable:				the name of the resource table to use
		*	cReturnToOnCancel:			the name of the program to return to when
		*								Cancel is chosen
		*	cReturnToOnQuit:			the name of the program to return to when
		*								Quit is chosen
		*	cSenderEmail:				the sender's email address
		*	cSenderName:				the name of the sender
		*	cSubject:					the subject of the error message
		*	cTitle:						the default title for the error message dialog
		*	cUser:						the name of the user
		*	cUserName:					the email user name
		*	cVersion:					the application version number
		*	lAutoCreateTicket:			.T. to automatically create a ticket
		*	lCanCancel:					.T. if the user can "cancel" (that is, stay in
		*								the application)
		*	lCanContinue:				.T. if the user can "continue" (that is, RETRY
		*								or RETURN)
		*	lDisplayErrors:				.T. if we're supposed to display errors and get
		*								the user's choice
		*	lDisplayingErrorDialog:		.T. if we're displaying the error dialog
		*	lEmailLogging:				.T. to do email logging
		*	lGetMemVars:				.T. to include memory variables in the error
		*								report; .F. if an ActiveX control would cause a
		*								buffer overrun
		*	lGettingMemVars:			.T. if we're using LIST MEMORY or LIST OBJECTS;
		*								an Access method can check it and do nothing if
		*								.T.
		*	lHandlingError:				.T. if we're in the process of handling an
		*								error
		*	lInsideTry:					.T. if code was executing inside a TRY
		*								structure when the error occurred
		*	lLogToTable:				.T. if the error should be logged to a table
		*	lMAPI:						.T. to use MAPI
		*	lQuit:						.T. if we're quitting (public so other objects
		*								can check on the way out)
		*	lScreenShot:				.T. to take a screen shot
		*	lSetOnError:				.T. to set ON ERROR to point to the
		*								ErrorHandler method
		*	lShowDebug:					.T. if "debug" should be an option
		*	lTicketCreated:				.T. if a ticket was created
		*	lUserCanSaveDialog:			.T. if the user can save the error log
		*	nDataSession:				the datasession the error occurred in
		*	nLastError:					the index to the last error that occurred in
		*								aErrorInfo
		*	nMaxErrors:					the maximum number of entries in aErrorInfo;
		*								0 = no limit
		*	nReturnCode:				the return code for ExitProcess
		*	nSMTPPort:					the SMTP port to use
		*	nSecurityOptions:			the SecureSocketOptions setting to use
		*	nThrottleErrorCount:		the number of errors that have to occur within
		*								the timeframe specified in nThrottleThreshold
		*								to cause error suppression
		*	nThrottleThreshold:			the number of seconds nThrottleErrorCount
		*								errors must occur within for error suppression
		*								to be enabled
		*	nThrottleWindow:			how long to wait when error throttling before
		*								errors suppression is disabled
		*	tThrottleTime:				when error suppression started
		*
		* Custom protected properties added:
		*	cCurrError:					the former ON ERROR handler
		*	lErrorInfoSaved:			.T. if the error information has been saved in
		*								aErrorInfo
		*	lErrorOccurred:				.T. if an error occurred
		*	lSuppressErrors:			if .T., an error isn't logged or displayed
		*
		* Custom public methods added:
		*	CheckInTry:					checks to see if we're in a TRY structure
		*								somewhere in the call stack
		*	CreateMailObject:			creates a mail object
		*	CreateTicket:				creates a support ticket
		*	Decrypt:					decrypts a string
		*	CreateTicketOrEmail:		creates a ticket or sends an email
		*	DidErrorOccur:				an exposed method to return the value of the
		*								protected lErrorOccurred
		*	DisplayError:				displays an error message to the user
		*	ErrorHandler:				handles an error
		*	GetMemVars:					creates a list of memvars and their values
		*	ImmediateExit:				performs an immediate exit
		*	LogError:					logs the error to a log file
		*	ResetError:					an exposed method to reset the values of the
		*								protected lErrorOccurred and public aErrorInfo
		*	RevertAllTables:			reverts all cursors in all datasessions
		*	RevertTables:				revert cursors in the current datasession
		*	ScreenShot:					takes a screen shot
		*	SetDialogProperties:		sets properties of the error dialog before
		*								displaying it
		*	SetError:					sets lErrorOccurred and aErrorInfo to
		*								information about the most recent error
		*	SetSuppressErrors:			an exposed method to set the value of the
		*								protected lSuppressErrors
		*
		* Custom protected methods added:
		*	CleanupBeforeReturn:		provides an opportunity to clean things up
		*								before RETURN TO is used
		*	CommandShell:				displays a pseudo-command window at runtime
		*	CreateErrorMessage:			creates a string describing the error
		*	IsReturnToOnCallStack:		determines if the specified routine is on the
		*								call stack
		*==============================================================================
		
	ENDPROC

	PROCEDURE checkintry		&& Checks to see if we're in a TRY structure somewhere in the call stack
		*==============================================================================
		* Method:			CheckInTry
		* Status:			Public
		* Purpose:			Checks to see if we're in a TRY structure somewhere in the
		*						call stack
		* Author:			Doug Hennig
		* Last Revision:	02/18/2023
		* Parameters:		none
		* Returns:			.T. if we're in a TRY structure somewhere in the call stack
		* Environment in:	wwDotNetBridge is loaded into oBridge or is available to be
		*						loaded
		*					InTry.dll exists
		* Environment out:	wwDotNetBridge and InTry.dll are loaded if they weren't
		*						before
		*==============================================================================
		
		local llInsideTry, ;
			lcOnError
		llInsideTry = This.lInsideTry
		if file('InTry.dll')
		
		* Although it would be good to wrap this in a TRY, that would make IsTryActive
		* always return .T. So, we'll use ON ERROR instead to eat any errors.
		
			lcOnError = on('ERROR')
			on error *
		
		* Use InTry.dll to see if we're inside a TRY.
		
			if type('oBridge') <> 'O'
				llLoaded = .F.
				lnTries  = 0
				do while not llLoaded and lnTries < 5
					try
						do wwDotNetBridge
						oBridge = GetwwDotNetBridge()
						oBridge.LoadAssembly('InTry.dll')
						llLoaded = .T.
					catch
						lnTries = lnTries + 1
					endtry
				enddo while not llLoaded and lnTries < 5
			endif type('oBridge') <> 'O'
			llInsideTry = oBridge.InvokeStaticMethod('InTry.InTry', 'IsTryActive', ;
				_vfp)
			if vartype(llInsideTry) <> 'L'
				llInsideTry = This.lInsideTry
			endif vartype(llInsideTry) <> 'L'
		
		* Restore the error handler.
		
			on error &lcOnError
		endif file('InTry.dll')
		return llInsideTry
		
	ENDPROC

	PROTECTED PROCEDURE cleanupbeforereturn		&& Provides an opportunity to clean things up before RETURN TO is used
		* Abstract method
		
	ENDPROC

	PROTECTED PROCEDURE commandshell		&& Displays a pseudo-command window at runtime
		*===============================================================================
		* Method:			CommandShell
		* Purpose:			Command shell for runtime environments
		* Author:			Doug Hennig
		* Last Revision:	10/21/2022
		* Parameters:		none
		* Environment in:	This.cConsoleClass and This.cConsoleLibrary contain the
		*					class and library to use for the debugging console
		* Environment out:	none
		* Routines used:	none
		*===============================================================================
		
		local loForm
		loForm = newobject(This.cConsoleClass, This.cConsoleLibrary)
		loForm.Show(1)
		return
		
	ENDPROC

	PROTECTED PROCEDURE createerrormessage		&& Creates a string describing the error
		*==============================================================================
		* Method:			CreateErrorMessage
		* Status:			Protected
		* Purpose:			Create a string describing the error
		* Author:			Doug Hennig
		* Last revision:	07/01/2022
		* Parameters:		none
		* Returns:			a string describing the error
		* Environment in:	This.aErrorInfo is filled with error information
		*					This.nLastError points to the current row in
		*						This.aErrorInfo
		* Environment out:	none
		*==============================================================================
		
		local luErrWorkArea, ;
			lcErrSource, ;
			lnErrNumber, ;
			luErrTrigger, ;
			luErrExtra1, ;
			luErrExtra2, ;
			ltErrTime, ;
			lcErrUser, ;
			lcErrMessage, ;
			lnErrLine, ;
			lcErrMethod, ;
			lcErrObject, ;
			lcLine1, ;
			lcLine2, ;
			lcLine3, ;
			lcLine4, ;
			lnPos, ;
			lcModule, ;
			lnPos2, ;
			lcObject, ;
			lcMethod, ;
			lcLine5, ;
			lcLine6, ;
			lcLine7, ;
			lcMessage
		with This
		
		* Initialize information about the error.
		
			luErrWorkArea = .aErrorInfo[.nLastError, cnAERR_WORKAREA]
			lcErrSource   = .aErrorInfo[.nLastError, cnAERR_SOURCE]
			lnErrNumber   = evl(.aErrorInfo[.nLastError, cnAERR_NUMBER], 0)
			luErrTrigger  = .aErrorInfo[.nLastError, cnAERR_TRIGGER]
			luErrExtra1   = .aErrorInfo[.nLastError, cnAERR_EXTRA1]
			luErrExtra2   = .aErrorInfo[.nLastError, cnAERR_EXTRA2]
			ltErrTime     = evl(.aErrorInfo[.nLastError, cnAERR_DATETIME], datetime())
			lcErrUser     = .aErrorInfo[.nLastError, cnAERR_USER]
			lcErrMessage  = .aErrorInfo[.nLastError, cnAERR_MESSAGE]
			lnErrLine     = evl(.aErrorInfo[.nLastError, cnAERR_LINE], 0)
			lcErrMethod   = .aErrorInfo[.nLastError, cnAERR_METHOD]
			lcErrObject   = .aErrorInfo[.nLastError, cnAERR_OBJECT]
			lcLine1       = trim(ccMSG_ERROR_NUM) + ' ' + ;
				transform(lnErrNumber)
			lcLine2       = trim(ccMSG_MESSAGE) + ' ' + lcErrMessage
			lcLine3       = iif(lnErrLine = 0, '', trim(ccMSG_LINE_NUM) + ' ' + ;
				transform(lnErrLine))
			lcLine4       = iif(empty(lcErrSource) or lcErrSource = lcErrMessage or ;
				lnErrLine = 0, '', trim(ccMSG_CODE) + ' ' + lcErrSource)
		
		* Figure out the object, method, and module.
		
			lnPos = at(' ', lcErrMethod, 2)
			if lnPos = 0
				lcModule = ''
				lcObject = lcErrMethod
			else
				lcModule = substr(lcErrMethod, lnPos + 1)
				lcModule = substr(lcModule, rat('\', lcModule) + 1)
				lcObject = left(lcErrMethod, lnPos - 1)
				lcObject = substr(lcObject, at(' ', lcObject) + 1)
			endif lnPos = 0
			lnPos    = rat('.', lcObject)
			lcMethod = substr(lcObject, lnPos + 1)
			if lcMethod $ 'FXP,MPX,PRG,MPR' or lnPos = 0
				lcMethod = ''
				lcObject = juststem(lcObject)
			else
				lcObject = left(lcObject, lnPos - 1)
			endif lcMethod $ 'FXP,MPX,PRG,MPR' ...
			lcLine5   = iif(empty(lcMethod), '', trim(ccMSG_METHOD) + ' ' + ;
				lcMethod)
			lcLine6   = trim(ccMSG_OBJECT) + ' ' + lcObject
			lcLine7   = iif(empty(lcModule), '', trim(ccMSG_MODULE) + ' ' + ;
				lcModule)
			lcMessage = lcLine1 + ccCRLF + lcLine2 + ccCRLF + ;
				iif(empty(lcLine3), '', lcLine3 + ccCRLF) + ;
				iif(empty(lcLine4), '', lcLine4 + ccCRLF) + ;
				iif(empty(lcLine5), '', lcLine5 + ccCRLF) + lcLine6 + ;
				ccCRLF + iif(empty(lcLine7), '', lcLine7 + ccCRLF)
		endwith
		return lcMessage
		
	ENDPROC

	PROCEDURE createmailobject		&& Creates a mail object
		*==============================================================================
		* Method:			CreateMailObject
		* Status:			Public
		* Purpose:			Creates a mail object
		* Author:			Doug Hennig
		* Last Revision:	03/22/2021
		* Parameters:		none
		* Returns:			a mail object
		* Environment in:	This.cMailClass and This.cMailLibrary are set to the
		*						desired class and library
		* Environment out:	none
		*==============================================================================
		
		local loMail
		loMail = newobject(This.cMailClass, This.cMailLibrary)
		return loMail
		
	ENDPROC

	PROCEDURE createticket		&& Creates a support ticket
		*==============================================================================
		* Method:			CreateTicket
		* Status:			Public
		* Purpose:			Creates a support ticket
		* Author:			Doug Hennig
		* Last Revision:	03/19/2021
		* Parameters:		tcMessage     - the message
		*					tcEmail       - the email address of the user
		*					tcContact     - the name of the user
		*					tcAttachments - a comma-separated list of attachments
		* Returns:			.T. if it succeeded
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		* Abstract method.
		
		lparameters tcMessage, ;
			tcEmail, ;
			tcContact, ;
			tcAttachments
		return .F.
		
	ENDPROC

	PROCEDURE createticketoremail		&& Creates a ticket or sends an email
		*==============================================================================
		* Method:			CreateTicketOrEMail
		* Status:			Public
		* Purpose:			Creates a ticket or sends an email
		* Author:			Doug Hennig
		* Last Revision:	07/14/2022
		* Parameters:		tcMessage - the message for the ticket or email
		*					tcEmail   - the email address to use
		*					tcContact - the name of the user
		* Returns:			.T. if it succeeded
		* Environment in:	the various email properties are set
		* Environment out:	a ticket was created or email sent
		*==============================================================================
		
		lparameters tcMessage, ;
			tcEmail, ;
			tcContact
		local lcEmail, ;
			lcContact, ;
			lcAttachments, ;
			llOK, ;
			loMail
		with This
			lcEmail         = evl(tcEmail,   .cSenderEmail)
			lcContact       = evl(tcContact, .cSenderName)
			lcAttachments   = .cErrorLogTextFile + ;
				iif(.lScreenShot and not empty(.cImageFile), ',' + .cImageFile, '') + ;
				iif(empty(.cAttachments), '', ',' + .cAttachments)
			.lTicketCreated = .F.
			llOK            = .CreateTicket(tcMessage, lcEmail, lcContact, lcAttachments)
			.lTicketCreated = llOK
			if not llOK and not empty(.cRecipient)
				loMail = .CreateMailObject()
				loMail.cRecipients  = .cRecipient
				loMail.cSubject     = .cSubject
				loMail.cBody        = tcMessage
				loMail.cAttachments = lcAttachments
				if not .lMAPI and empty(loMail.cServer)
					&& SMTP settings may have been set in CreateMailObject in a subclass
					loMail.lUseMAPI         = .F.
					loMail.cServer          = .cMailServer
					loMail.cSenderEmail     = evl(.cSenderEmail, lcEmail)
						&& some servers require the sender email to match an
						&& authenticated name; cReplyTo allows us to possibly have a
						&& different Reply-To address than the sender
					loMail.cReplyTo         = lcEmail
					loMail.cSenderName      = lcContact
					loMail.cLogFile         = iif(empty(.cEmailLogFolder), '', ;
						.cEmailLogFolder + 'EmailLog.txt')
					loMail.nSMTPPort        = .nSMTPPort
					loMail.nSecurityOptions = .nSecurityOptions
					loMail.cUser            = .cUserName
					loMail.cPassword        = .cPassword
					if not empty(loMail.cPassword)
						loMail.cPassword = .Decrypt(.cPassword, .cUserName)
					endif not empty(loMail.cPassword)
				endif not .lMAPI ...
				llOK = loMail.SendMail()
				if not llOK
					.cMailErrorMessage = loMail.cErrorMessage
				endif not llOK
			endif not llOK ...
		endwith
		return llOK
		
	ENDPROC

	PROCEDURE decrypt		&& Decrypts a string
		*==============================================================================
		* Method:			Decrypt
		* Status:			Public
		* Purpose:			Decrypts a string
		* Author:			Doug Hennig
		* Last Revision:	01/28/2022
		* Parameters:		tcString - the string to decrypt
		*					tcKey    - a key to decrypt against
		* Returns:			the decrypted string
		* Environment in:	oUtility is an object or VFPEncryption is loaded
		* Environment out:	none
		*==============================================================================
		
		lparameters tcString, ;
			tcKey
		local lcReturn, ;
			lcLibrary
		try
			if type('oUtility.Name') = 'C'
				lcReturn = oUtility.Decrypt(tcString, tcKey)
			else
				lcReturn = strtran(Decrypt(tcString, tcKey), ccNULL)
			endif type('oUtility.Name') = 'C'
		catch
			lcReturn = tcString
		endtry
		return lcReturn
		
	ENDPROC

	PROCEDURE Destroy
		*==============================================================================
		* Method:			Destroy
		* Status:			Public
		* Purpose:			Resets the former ON ERROR handler as the object is
		*						destroyed
		* Author:			Doug Hennig
		* Last revision:	12/23/96
		* Parameters:		None
		* Returns:			.T.
		* Environment in:	if This.lSetOnError is .T., This.cCurrError contains the
		*						former ON ERROR handler
		* Environment out:	if This.lSetOnError is .T., the ON ERROR handler is reset
		*						to the contents of This.cCurrError
		*==============================================================================
		
		local lcError
		with This
			if .lSetOnError
				lcError = .cCurrError
				on error &lcError
			endif .lSetOnError
		endwith
		
	ENDPROC

	PROCEDURE diderroroccur		&& An exposed method to return the value of the protected lErrorOccurred.
		*==============================================================================
		* Method:			DidErrorOccur
		* Status:			Public
		* Purpose:			Determines if an error occurred (an exposed method to
		*						return the value of the protected property
		*						This.lErrorOccurred
		* Author:			Doug Hennig
		* Last revision:	08/23/96
		* Parameters:		None
		* Returns:			.T. if an error occured
		* Environment in:	This.lErrorOccurred is .T. if an error occurred
		* Environment out:	none
		*==============================================================================
		
		return This.lErrorOccurred
		
	ENDPROC

	PROCEDURE displayerror		&& Displays an error message to the user.
		*==============================================================================
		* Method:			DisplayError
		* Status:			Protected
		* Purpose:			Display an error dialog and allow the user to decide what
		*						to do about it
		* Author:			Doug Hennig
		* Last revision:	01/28/2022
		* Parameters:		none
		* Returns:			the user's choice (as the caption of the button selected)
		* Environment in:	see CreateErrorMessage for details
		* Environment out:	a dialog of choices has been displayed to the user and one
		*						of several choices taken
		*==============================================================================
		
		local llScreen, ;
			lnLeft, ;
			lcMessage, ;
			loMessage, ;
			lcChoice
		
		* Bug out now if we're running in a COM server
		
		if inlist(_vfp.StartMode, 2, 3, 5)
			return
		endif inlist(_vfp.StartMode, 2, 3, 5)
		
		* Set LockScreen to the topmost form to .F. just in case.
		
		if type('_screen.ActiveForm.LockScreen') = 'L'
			_screen.ActiveForm.LockScreen = .F.
		endif type('_screen.ActiveForm.LockScreen') = 'L'
		
		* Flag whether we can cancel (that is, stay in the app) or not.
		
		This.lCanCancel = not This.lInsideTry and ;
			This.cReturnToOnCancel <> 'STARTUP' and ;
			This.IsReturnToOnCallStack(This.cReturnToOnCancel)
		
		* Because the error dialog may need to appear in a top-level form (TLF) and we
		* may not have one if the application has _SCREEN turned off and no TLF has
		* been shown yet, we'll make _SCREEN visible.
		
		llScreen = _screen.Visible
		if not llScreen
			lnLeft          = _screen.Left
			_screen.Left    = -10000
			_screen.Visible = .T.
		endif not llScreen
		
		* Display the messagebox and find out the user's choice.
		
		loMessage = newobject(This.cMessageClass, This.cMessageLibrary, '', This)
		This.SetDialogProperties(loMessage)
		This.lDisplayingErrorDialog = .T.
		loMessage.Show()
		This.lDisplayingErrorDialog = .F.
		lcChoice = iif(vartype(loMessage) = 'O' and pemstatus(loMessage, 'cChoice', 5), ;
			loMessage.cChoice, ccMSG_CONTINUE)
		
		* Hide _SCREEN if necessary.
		
		if not llScreen
			_screen.Left    = lnLeft
			_screen.Visible = .F.
		endif not llScreen
		return lcChoice
		
	ENDPROC

	PROCEDURE errorhandler		&& The ON ERROR handler.
		*==============================================================================
		* Method:			ErrorHandler
		* Status:			Public
		* Purpose:			Handle errors
		* Author:			Doug Hennig
		* Last revision:	04/26/2022
		* Parameters:		tnError       - the error number
		*					tcMethod      - the method or function the error occurred in
		*					tnLine        - the line number within tcMethod
		*					tcAlias       - the selected alias
		*					tnDataSession - the selected datasession ID
		* Returns:			the choice made by the user or This.cDefaultAction if
		*						This.lSuppressErrors is .T.
		* Environment in:	This.lDisplayErrors is .T. if an message should be
		*						displayed
		*					This.lLogErrors is .T. if error information should be
		*						logged
		*					This.lAutoCreateTicket is .T. if a support ticket should
		*						be created
		*					This.lScreenShot is .T. if a screen shot should be taken
		*						(This.lDisplayErrors or This.lAutoCreateTicket must
		*						also be .T.)
		*					This.lSuppressErrors is .T. if no message should be
		*						displayed and no error logged
		*					The "throttle" properties are set if error throttling
		*						should occur
		*					oLocalizer may be accessible and contain an SFLocalizer
		*						object
		* Environment out:	This.lErrorOccurred is .T.
		*					This.cAlias is set to tcAlias
		*					This.aErrorInfo is filled with error information (see
		*						the SetError method for the structure of the array)
		*					This.lInsideTry is .F.
		*					This.cMessage is set to the return value of
		*						This.CreateErrorMessage
		*					a dialog of choices may have been displayed to the user
		*						and one of up to five choices taken:
		*
		*						- Debug (only if This.lShowDebug is .T.): brings up the
		*							Trace and Debug windows
		*						- Continue: returns to the command following the one
		*							that caused the error
		*						- Retry: retries the command
		*						- Cancel: issues CLEAR EVENTS and returns to the top
		*							level program (only if This.lInsideRetry is .F.)
		*						- Quit: quit the application (in which case, This.lQuit
		*							is .T.
		*==============================================================================
		
		lparameters tnError, ;
			tcMethod, ;
			tnLine, ;
			tcAlias, ;
			tnDataSession
		local lcCurrTalk, ;
			laError[1], ;
			lcMessage, ;
			llOriginalInsideTry, ;
			llInsideTry, ;
			lcChoice, ;
			llReturn, ;
			lcReadEventsProgram, ;
			lcMasterProgram, ;
			llLogToTable, ;
			llScreenShot, ;
			llReturnTo, ;
			llReturnToMaster, ;
			loException as Exception
		
		* Ensure TALK and NULL are off.
		
		if set('TALK') = 'ON'
			set talk off
			lcCurrTalk = 'ON'
		else
			lcCurrTalk = 'OFF'
		endif set('TALK') = 'ON'
		set null off
		
		* Flag that we're handling an error; the Timer method of a timer could use this
		* to decide to do nothing, for example.
		
		This.lHandlingError = .T.
		
		* Grab the error information.
		
		aerror(laError)
		lcMessage         = message(1)
		This.cAlias       = evl(tcAlias, '')
		This.nDataSession = evl(tnDataSession, 1)
		
		* If we have a logging object, log the error.
		
		if type('oLogger.Name') = 'C'
			oLogger.LogMilestone('SFErrorMgr.ErrorHandler: error ' + ;
				transform(tnError) + ' in line ' + transform(tnLine) + ' of ' + ;
				transform(tcMethod))
		endif type('oLogger.Name') = 'C'
		
		* See if a TRY is active somewhere on the call stack. We'll initially use
		* This.lInsideTry for backward compatibility, but then use InTry.dll if it
		* exists.
		
		llOriginalInsideTry = This.lInsideTry
		llInsideTry         = This.CheckInTry()
		This.lInsideTry     = llInsideTry
		with This
			try
		
		* Set the default return value to This.cDefaultAction.
		
				lcChoice = .cDefaultAction
				do case
		
		* Ignore "DataEnvironment already unloaded", "Error loading printer driver",
		* and "Collate sequence not found" errors.
		
					case inlist(tnError, cnERR_DE_UNLOADED, cnERR_PRINTER_DRIVER, ;
						cnERR_COLLATE_NOT_FOUND)
		
		* Handle any other error. First, save the error information if it hasn't
		* already been done.
		
					otherwise
						if not .lErrorInfoSaved
							.SetError(tcMethod, tnLine, lcMessage, @laError)
						endif not .lErrorInfoSaved
						.lErrorInfoSaved    = .F.
						.cMessage           = .CreateErrorMessage()
						.cSubject           = 'Error in ' + .cAppName + ;
							' Version ' + .cVersion
						llReturn            = .IsReturnToOnCallStack(.cReturnToOnCancel)
						lcReadEventsProgram = .cReturnToOnCancel
						lcMasterProgram     = .cReturnToOnQuit
		
		* If we don't have a localizer object, create one if SFLocalize.vcx is
		* available.
		
						if type('oLocalizer.Name') <> 'C' and file('SFLocalize.vcx')
							private oLocalizer
							oLocalizer                = newobject('SFLocalize', 'SFLocalize.vcx')
							oLocalizer.cLanguage      = .cLanguage
							oLocalizer.cResourceTable = .cResourceTable
						endif type('oLocalizer.Name') <> 'C' ...
		
		* Handle error throttling.
		
						do case
		
		* Throttling isn't in effect.
		
							case .nThrottleThreshold = 0
		
		* If this error occurred less than the threshold time after an earlier one,
		* suppress errors for a while.
		
							case not .lSuppressErrors and ;
								.nLastError >= .nThrottleErrorCount and ;
								.aErrorInfo[.nLastError, cnAERR_DATETIME] - ;
									.aErrorInfo[.nLastError - .nThrottleErrorCount + 1, ;
									cnAERR_DATETIME] < .nThrottleThreshold
								.lSuppressErrors = .T.
								.tThrottleTime   = .aErrorInfo[.nLastError, cnAERR_DATETIME]
								if type('oLocalizer.Name') = 'C'
									lcMessage = oLocalizer.GetLocalizedString('MSG_ERRORS_SUPPRESSED')
								else
									lcMessage = 'Note: errors are being ' + ;
										'suppressed for the next {0} minutes.'
								endif type('oLocalizer.Name') = 'C'
								lcMessage = strtran(lcMessage, '{0}', ;
									transform(round(.nThrottleWindow/60, 0)))
								.cMessage = .cMessage + ccCRLF + ccCRLF + lcMessage
								llLogToTable = .lLogToTable
								.lLogToTable = .F.
								.LogError()
								.lLogToTable = llLogToTable
								.CreateTicketOrEmail(.cMessage, .cEmail, .cContact)
		
		* If errors are suppressed and we've surpassed the throttle window, disable
		* suppression.
		
							case .lSuppressErrors and ;
								.aErrorInfo[.nLastError, cnAERR_DATETIME] - .tThrottleTime > .nThrottleWindow
								.lSuppressErrors = .F.
		
		* If errors are suppressed and we haven't surpassed the throttle window, reset
		* the suppression start time (we need nThrottleWindow seconds of "quiet" time
		* before we disable suppression).
		
							case .lSuppressErrors
								.tThrottleTime = .aErrorInfo[.nLastError, cnAERR_DATETIME]
						endcase
		
		* If errors aren't being suppressed, log and display the error.
		
						if not .lSuppressErrors
							.LogError()
		
		* Take a screen shot if we're supposed to.
		
							llScreenShot = .lScreenShot and ;
								(.lAutoCreateTicket or .lDisplayErrors)
							if llScreenShot
								.ScreenShot()
							endif llScreenShot
		
		* If we're supposed to create a support ticket, do so.
		
							if .lAutoCreateTicket
								.CreateTicketOrEmail(.cMessage, .cEmail, .cContact)
							endif .lAutoCreateTicket
		
		* Display the error and get the user's choice if desired.
		
							if .lDisplayErrors
								lcChoice = .DisplayError()
							endif .lDisplayErrors
		
		* Delete the screen shot if we created it.
		
							if llScreenShot
								try
									erase (.cImageFile)
								catch
								endtry
							endif llScreenShot
		
		* Delete the log file we created.
		
							try
								erase (.cErrorLogTextFile)
							catch
							endtry
						endif not .lSuppressErrors
				endcase
				do case
		
		* Cancel or Quit in development environment: remove any WAIT window, revert all
		* open cursors and issue a CLEAR EVENTS (in the case of Quit), and then return
		* to the top-level program.
		
					case lcChoice = ccMSG_CANCEL or ;
						(lcChoice = ccMSG_QUIT and version(2) <> 0)
						wait clear
						if lcChoice = ccMSG_QUIT
							.lQuit   = .T.
							llReturn = .F.
							.RevertAllTables()
							clear events
						endif lcChoice = ccMSG_QUIT
						llReturnTo       = .T.
						llReturnToMaster = .IsReturnToOnCallStack(.cReturnToOnQuit)
		
		* Display the debugger (runtime environment): use a pseudo command window.
		
					case lcChoice = ccMSG_DEBUG and version(2) = 0
						.CommandShell()
						lcChoice = ccMSG_CONTINUE
		
		* Display the debugger (development environment).
		
					case lcChoice = ccMSG_DEBUG
						_screen.Visible = .T.
						debug
						if wexist('Visual FoxPro Debugger')
							keyboard '{SHIFT+F7}' plain
						endif wexist('Visual FoxPro Debugger')
						suspend
		
		* Quit: revert all open cursors, CLEAR EVENTS, and return to the top-level
		* program.
		
					case lcChoice = ccMSG_QUIT
						.lQuit = .T.
						.RevertAllTables()
						on shutdown
						clear events
						llReturnTo = .T.
				endcase
		
		* Restore TALK.
		
				if lcCurrTalk = 'ON'
					set talk on
				endif lcCurrTalk = 'ON'
		
		* If an exception happens in the error handler itself, open the debugger (only
		* when running in the IDE).
		
			catch to loException
				set step on 
			endtry
		endwith
		
		* Turn off the flag.
		
		This.lHandlingError = .F.
		
		* Return to the appropriate location (we have to do it here rather than in the
		* TRY structure). We may not be able to do that if we're inside a TRY structure
		* somewhere, since RETURN isn't allowed.
		
		This.lInsideTry = llOriginalInsideTry
		addproperty(_screen, 'ErrorChoice', lcChoice)
			&& in case a subclass does CLEAR ALL in one of the methods called below
		do case
			case lcChoice = ccMSG_RETRY
				retry
			case inlist(_vfp.StartMode, 2, 3, 5)
				comreturnerror(This.cAppName, ;
					This.aErrorInfo[This.nLastError, cnAERR_MESSAGE])
			case not llReturnTo
			case llInsideTry or (version(2) = 0 and llReturn and ;
				lcReadEventsProgram = 'STARTUP') or (not llReturn and ;
				not llReturnToMaster)
				This.ImmediateExit()
			case llReturn
				This.CleanupBeforeReturn()
				return to &lcReadEventsProgram
			otherwise
				This.lQuit = .T.
				This.CleanupBeforeReturn()
				return to &lcMasterProgram
		endcase
		return _screen.ErrorChoice
		
	ENDPROC

	PROTECTED PROCEDURE getmemvars		&& Creates a list of memvars and their values
		* Output and clean up a list of variables.
		
		local lcFile, ;
			lnMemoWidth, ;
			lcVars, ;
			lcContents, ;
			laLines[1], ;
			lnLines, ;
			llDouble, ;
			llDelete, ;
			lnI, ;
			lcLine, ;
			lnPos, ;
			lcVariable, ;
			lcScope, ;
			lcType, ;
			lcRest, ;
			laLevels[1], ;
			lnLevels, ;
			lnJ, ;
			llRemove, ;
			llRemoveClass, ;
			llProperties, ;
			loForm, ;
			lnMembers, ;
			laPEMs[1], ;
			laClasses[1], ;
			lnClasses, ;
			lnMember, ;
			lcObject, ;
			llBlank, ;
			lnCurrSession, ;
			laSessions[1], ;
			lnSessions, ;
			lnSession, ;
			lcStatus, ;
			loVrbls, ;
			loVrbl
		lcFile      = addbs(sys(2023)) + sys(2015) + '.TXT'
		lnMemoWidth = set('MEMOWIDTH')
		set memowidth to 1024
		lcVars = ''
		if This.lGetMemVars
			This.lGettingMemVars = .T.
		* Tamar gets buffer overrun with this. Solution was to use LIST MEMORY LIKE A*, LIST MEMORY LIKE B*, etc.
			try
				list memory noconsole to file (lcFile)
			catch
			endtry
			This.lGettingMemVars = .F.
			if file(lcFile)
				lcContents = filetostr(lcFile)
				alines(laLines, lcContents, .T., ccCRLF, ccCR, ccLF)
				lnLines = ascan(laLines, 'Print System Memory Variables') - 4
			else
				lnLines = 0
			endif file(lcFile)
			if lnLines > 0
				dimension laLines[lnLines]
				llDouble = .F.
				llDelete = .F.
				for lnI = 1 to lnLines
					lcLine = laLines[lnI]
					lnPos  = at(' ', lcLine)
					do case
						case lnPos > 0 and llDouble
							lcScope = alltrim(left(lcLine, lnPos))
							lcLine  = alltrim(substr(lcLine, lnPos))
							lnPos   = at(' ', lcLine)
							if lnPos > 0
								lcType = alltrim(left(lcLine, lnPos))
								lcRest = alltrim(substr(lcLine, lnPos))
							else
								lcType = ''
								lcRest = lcLine
							endif lnPos > 0
						case lnPos > 0
							lcVariable = alltrim(left(lcLine, lnPos))
							lcLine     = alltrim(substr(lcLine, lnPos))
							lnPos      = at(' ', lcLine)
							if lnPos = 0
								store '' to lcScope, lcType
								lcRest = lcLine
							else
								lcScope    = alltrim(left(lcLine, lnPos))
								lcLine     = alltrim(substr(lcLine, lnPos))
								lnPos      = at(' ', lcLine)
								if lnPos > 0
									lcType = alltrim(left(lcLine, lnPos))
									lcRest = alltrim(substr(lcLine, lnPos))
								else
									lcType = ''
									lcRest = lcLine
								endif lnPos > 0
							endif lnPos = 0
						otherwise
							lcVariable = alltrim(lcLine)
							store '' to lcScope, lcType, lcRest
							laLines[lnI] = ''
					endcase
					if m.lcType == 'N'
						lcRest = left(lcRest, at(' ', lcRest) + 1) + ;
							substr(lcRest, rat(' ', lcRest))
					endif m.lcType == 'N'
					lcLine = alltrim(lcVariable + ' ' + lcScope + ' ' + m.lcType + ' ' + lcRest)
					lnPos  = rat(' ', lcLine)
					do case
						case empty(lcLine)
							laLines[lnI] = ''
						case lnPos = 0
							llDouble = .T.
							llDelete = .F.
						case inlist(substr(lcLine, lnPos + 1), 'startup', ;
							'error', 'errorhandler', 'logerror', 'handleerror', ;
							'displayerror', 'sendmessage', 'getmemvars', ;
							'createattachment', 'createerrormessage', 'createlogfile', ;
							'handlesqlerror') or trim(lcVariable) = 'LCPASSWORD'
							laLines[lnI] = ''
							if llDouble
								laLines[lnI - 1] = ''
							endif llDouble
							llDouble = .F.
							llDelete = .T.
						case left(alltrim(lcLine), 1) = '(' and llDelete
							laLines[lnI] = ''
						case llDouble
							laLines[lnI - 1] = laLines[lnI - 1] + ;
								iif(empty(laLines[lnI - 1]), '', ' ') + lcLine
							laLines[lnI] = ''
							llDouble = .F.
						otherwise
							llDouble = .F.
							llDelete = .F.
							laLines[lnI] = lcLine
					endcase
				next lnI
				for lnI = 1 to lnLines
					if not empty(laLines[lnI])
						lcVars = lcVars + laLines[lnI] + ccCRLF
					endif empty(laLines[lnI])
				next lnI
			endif lnLines > 0
		endif This.lGetMemVars
		
		* Get the call stack.
		
		lcVars   = lcVars + ccCRLF + ccCRLF + 'Call stack:' + ccCRLF
		lnLevels = astackinfo(laLevels)
		for lnI = 1 to lnLevels
			for lnJ = 1 to 6
				lcVars = lcVars + transform(laLevels[lnI, lnJ]) + iif(lnJ = 6, '', ',')
			next lnJ
			lcVars = lcVars + ccCRLF
		next lnI
		
		* Now handle objects.
		
		try
			This.lGettingMemVars = .T.
			list objects noconsole to file (lcFile)
			This.lGettingMemVars = .F.
			lcContents    = filetostr(lcFile)
			lnLines       = alines(laLines, lcContents, .T., ccCRLF, ccCR, ccLF)
			llRemove      = .F.
			llRemoveClass = .F.
			llProperties  = .F.
			loForm        = createobject('Form')
			lnMembers     = amembers(laPEMs, loForm, 0)
			laClasses     = ''
			lnClasses     = 0
			lnMember      = ascan(laPEMS, 'Tag', -1, -1, 1, 15)
				&& remove Tag from list of members to ignore
			adel(laPEMS, lnMember)
			lnMembers = lnMembers - 1
			dimension laPEMs[lnMembers + 4]
			laPEMs[lnMembers + 1] = 'CPASSWORD'
			laPEMs[lnMembers + 2] = 'CUSERNAME'
			laPEMs[lnMembers + 3] = 'CMAILUSER'
			laPEMs[lnMembers + 4] = 'CMAILSERVER'
			for lnI = 1 to lnLines
				laLines[lnI] = strtran(laLines[lnI], space(20), space(1))
				lcLine = laLines[lnI]
				do case
					case empty(lcLine)
						laLines[lnI] = chr(255)
					case lcLine = 'Object:'
						lcObject = strextract(lcLine, ': ', ' ')
						if inlist(lcObject, 'OUTILITY', 'OMESSAGE', 'OLICENSE', 'OUSER', ;
							'OLOGGER', 'OERROR', 'OREGISTRY', 'OREGISTRYODBC', 'OMENU', ;
							'OLOCALIZER', 'SQAPPLICATION', 'LOJOINOBJECT', 'LOBESTJOIN', ;
							'LOMESSAGE', 'LOJOIN', 'LOERROR', 'OBRIDGE', '__VFP') or ;
							ascan(laClasses, lcObject, -1, -1, 1, 7) > 0
							laLines[lnI]  = ''
							llRemoveClass = .T.
						else
							llRemoveClass = .F.
							lnClasses     = lnClasses + 1
							dimension laClasses[lnClasses]
							laClasses[lnClasses] = lcObject
						endif inlist(lcObject ...
						llProperties = .F.
					case llRemoveClass
						laLines[lnI] = ''
					case inlist(lcLine, 'Class Tree:', 'Methods and Events:', ;
						'Member Objects:')
						laLines[lnI] = ''
						llRemove     = .T.
						llProperties = .F.
					case lcLine = 'Properties:' or llProperties
						lcProperty = strextract(alltrim(lcLine), '', ' ')
						if not empty(lcProperty) and ascan(laPEMS, lcProperty) > 0
							laLines[lnI] = ''
						endif not empty(lcProperty) ...
						llProperties = .T.
						llRemove     = .F.
					case llRemove
						laLines[lnI] = ''
				endcase
			next lnI
			llBlank = .F.
			for lnI = 1 to lnLines
				lcLine = laLines[lnI]
				if not empty(lcLine)
					if lcLine = chr(255)
						lcLine = ''
					endif lcLine = chr(255)
					if not empty(lcLine) or not llBlank
						lcVars = lcVars + lcLine + ccCRLF
					endif not empty(lcLine) ...
					llBlank = empty(lcLine)
				endif not empty(lcLine)
			next lnI
			erase (lcFile)
		catch
		endtry
		
		* Now handle the status in the active datasession.
		
		lnCurrSession = set('DATASESSION')
		if lnCurrSession <> This.nDataSession
			try
				set datasession to This.nDataSession
			catch
			endtry
		endif lnCurrSession <> This.nDataSession
		list status noconsole to file (lcFile)
		lcVars = lcVars + 'Active Datasession: ' + transform(This.nDataSession) + ;
			ccCRLF + filetostr(lcFile) + ccCRLF
		erase (lcFile)
		
		* Now handle the status in other datasessions.
		
		lnSessions = asessions(laSessions)
		for lnI = 1 to lnSessions
			lnSession = laSessions[lnI]
			if lnSession <> This.nDataSession
				set datasession to lnSession
				list status noconsole to file (lcFile)
				lcStatus = filetostr(lcFile)
				lnPos    = at('Procedure file', lcStatus)
				lcStatus = left(lcStatus, lnPos - 1)
				lcVars   = lcVars + 'Datasession: ' + transform(lnSession) + ccCRLF + ;
					lcStatus + ccCRLF
				erase (lcFile)
			endif lnSession <> This.nDataSession
		next lnI
		set datasession to lnCurrSession
		
		* Now get environment variables.
		
		if type('oUtility.Name') = 'C'
			lcVars = lcVars + ccCRLF + ccCRLF + 'Environment variables:' + ccCRLF
			try
				loVrbls = oUtility.GetEnvironmentVariables()
				for each loVrbl in loVrbls
					lcVars = lcVars + loVrbl.Name + ' (' + loVrbl.UserName + '): ' + ;
						loVrbl.VariableValue + ccCRLF
				next loVrbl
			catch
			endtry
		endif type('oUtility.Name') = 'C'
		
		* Clean up and exit.
		
		set memowidth to lnMemoWidth
		return lcVars
		
	ENDPROC

	PROCEDURE immediateexit		&& Performs an immediate exit
		local laHandles[1], ;
			lnHandles, ;
			lnI
		
		* Close all open ODBC connections.
		
		try
			lnHandles = asqlhandles(laHandles)
			for lnI = 1 to lnHandles
				sqldisconnect(laHandles[lnI])
			next lnI
		catch
		endtry
		
		* Set the return code and exit the process if we're in a runtime environment.
		
		if version(2) = 0
			try
				declare ExitProcess in Win32API integer ExitCode
				ExitProcess(This.nReturnCode)
			catch
				quit
			endtry
		else
		
		* Cleanup other things we may have changed.
		
			unbindevents(_screen)
			set classlib to
			set library to
			set procedure to
			set help to
			on error
			on shutdown
			_screen.MousePointer = 0
			_screen.Visible      = .T.
			clear events
		
		* Terminate the program.
		
			try
				clear all
			catch
			endtry
			cancel
		endif version(2) = 0
		
	ENDPROC

	PROCEDURE Init
		*==============================================================================
		* Method:			Init
		* Status:			Public
		* Purpose:			Initialize this class
		* Author:			Doug Hennig
		* Last revision:	04/26/2022
		* Parameters:		tcTitle       - the default title to use for the error
		*						dialog
		*					tlSetOnError  - .T. to set ON ERROR
		*					tcErrorObject - the name of the object this class will be
		*						instantiated into (optional: only needed if
		*						tlSetOnError is .T.; if it isn't passed "oError" is
		*						used)
		* Returns:			.T.
		* Environment in:	if tlSetOnError is .T., this class must be instantiated
		*						into the variable whose name is passed in tcErrorObject
		*					This.cEncryptionLibrary contains the name of an FLL to open
		* Environment out:	if tcTitle was passed, This.cTitle is set to it
		*					if tlSetOnError was passed, This.lSetOnError is set to it
		*					This.lErrorOccurred, This.lErrorInfoSaved, and
		*						This.lSuppressErrors are .F.
		*					This.aErrorInfo has been dimensioned to the desired number
		*						of columns and one row
		*					if This.lSetOnError is .T., This.cCurrError contains the
		*						former ON ERROR handler and ON ERROR is set to this
		*						class's ErrorHandler method
		*					This.cDefaultAction is set to ccMSG_CONTINUE (see
		*						SFERRORMGR.H for the value of this constant)
		*					This.lDisplayErrors is set to .F. if we're running in a COM
		*						server
		*					The library specified in This.cEncryptionLibrary was opened
		*==============================================================================
		
		* Set our message box title if one is passed. Set our lSetOnError property if
		* it's passed.
		
		lparameters tcTitle, ;
			tlSetOnError, ;
			tcErrorObject
		local lcErrorObj, ;
			lcError, ;
			lcLibrary
		with This
			if type('tcTitle') = 'C' and not empty(tcTitle)
				.cTitle = tcTitle
			endif type('tcTitle') = 'C' ...
			.lSetOnError = tlSetOnError
			lcErrorObj   = tcErrorObject
			if type('tcErrorObject') <> 'C' or empty(tcErrorObject)
				lcErrorObj = 'oError'
			endif type('tcErrorObject') <> 'C' ...
		
		* If necessary, point the ON ERROR method to our Errorhandler routine. Set
		* flags to default values.
		
			if .lSetOnError
				.cCurrError = on('ERROR')
				lcError = lcErrorObj + ".ErrorHandler(error(), sys(16), lineno(), " + ;
					"alias(), set('DATASESSION'))"
				on error &lcError
			endif .lSetOnError
			.lErrorOccurred  = .F.
			.lErrorInfoSaved = .F.
			.lSuppressErrors = .F.
			dimension .aErrorInfo[1, cnAERR_MAX]
			.aErrorInfo = ''
			.cDefaultAction = ccMSG_CONTINUE
		
		* If we're running in a COM server, disable displaying errors.
		
			if inlist(_vfp.StartMode, 2, 3, 5)
				.lDisplayErrors = .F.
			endif inlist(_vfp.StartMode, 2, 3, 5)
		
		* Open the encryption library.
		
			lcLibrary = lower(set('LIBRARY'))
			do case
				case file(.cEncryptionLibrary) and ;
					not lower(justfname(.cEncryptionLibrary)) $ lcLibrary
					set library to (.cEncryptionLibrary) additive
				case file('VFPEncryption.fll') and not 'vfpencryption.fll' $ lcLibrary
					set library to ('VFPEncryption.fll') additive
				case file('Encryption.fll') and not 'encryption.fll' $ lcLibrary
					set library to ('Encryption.fll') additive
			endcase
		endwith
		
	ENDPROC

	PROTECTED PROCEDURE isreturntooncallstack		&& Determines if the routine specified in cReturnToOnCancel is on the call stack
		*==============================================================================
		* Method:			IsReturnToOnCallStack
		* Status:			Protected
		* Purpose:			Determines if the specified routine is on the call stack
		* Author:			Doug Hennig
		* Last revision:	03/15/2021
		* Parameters:		tcReturnTo - the method to return to
		* Returns:			.T. if the specified routine is on the call stack
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		lparameters tcReturnTo
		local llReturn, ;
			lcReturn, ;
			lcReturnMethod, ;
			lnStack, ;
			lnI, ;
			lcProgram
		if upper(tcReturnTo) == 'MASTER'
			return .T.
		endif upper(tcReturnTo) == 'MASTER'
		lcReturn       = upper(tcReturnTo)
		lcReturnMethod = '.' + lcReturn
		lnStack        = program(-1)
		for lnI = 1 to lnStack
			lcProgram = program(lnI)
			if lcProgram == lcReturn or lcReturnMethod $ lcProgram
				llReturn = .T.
				exit
			endif lcProgram == lcReturn ...
		next lnI
		return llReturn
		
	ENDPROC

	PROCEDURE logerror		&& Logs the error to a log file.
		*==============================================================================
		* Method:			LogError
		* Status:			Protected
		* Purpose:			Log the error to a log file
		* Author:			Doug Hennig
		* Last revision:	07/13/2021
		* Parameters:		None
		* Returns:			.T.
		* Environment in:	This.cErrorLogFile contains the name of the error log table
		*					This.aErrorInfo contains information about the error
		*					This.cAlias contains the selected alias
		*					This.lLogToTable contains .T. if we're supposed to log the
		*						error to a table
		*					This.nLastError points to the current row in
		*						This.aErrorInfo
		* Environment out:	the error has been logged to the file and/or table
		*					This.cErrorLogTextFile contains the name of the error log
		*						text file
		*==============================================================================
		
		local luErrWorkArea, ;
			lcErrSource, ;
			lnErrNumber, ;
			luErrTrigger, ;
			luErrExtra1, ;
			luErrExtra2, ;
			ltErrTime, ;
			lcErrUser, ;
			lcErrMessage, ;
			lnErrLine, ;
			lcErrMethod, ;
			lcErrObject, ;
			lcErrMachine, ;
			lcCursor, ;
			lcSource, ;
			lcTrigger, ;
			lcOther1, ;
			lcOther2, ;
			lcVars, ;
			lcAlias, ;
			lnCurrSelect, ;
			lnHandle
		with This
		
		* Ensure SAFETY is off.
		
			lcSafety = set('SAFETY')
			set safety off
		
		* Put error information into variables.
		
			luErrWorkArea = .aErrorInfo[.nLastError, cnAERR_WORKAREA]
			lcErrSource   = .aErrorInfo[.nLastError, cnAERR_SOURCE]
			lnErrNumber   = evl(.aErrorInfo[.nLastError, cnAERR_NUMBER], 0)
			luErrTrigger  = .aErrorInfo[.nLastError, cnAERR_TRIGGER]
			luErrExtra1   = .aErrorInfo[.nLastError, cnAERR_EXTRA1]
			luErrExtra2   = .aErrorInfo[.nLastError, cnAERR_EXTRA2]
			ltErrTime     = evl(.aErrorInfo[.nLastError, cnAERR_DATETIME], datetime())
			lcErrUser     = .aErrorInfo[.nLastError, cnAERR_USER]
			lcErrMessage  = .aErrorInfo[.nLastError, cnAERR_MESSAGE]
			lnErrLine     = evl(.aErrorInfo[.nLastError, cnAERR_LINE], 0)
			lcErrMethod   = .aErrorInfo[.nLastError, cnAERR_METHOD]
			lcErrObject   = .aErrorInfo[.nLastError, cnAERR_OBJECT]
			lcErrMachine  = .aErrorInfo[.nLastError, cnAERR_MACHINE]
			do case
				case vartype(.cAlias) = 'C' and not empty(.cAlias)
					lcCursor = .cAlias
				case isnull(luErrWorkArea) or empty(luErrWorkArea)
					lcCursor = alias()
				case vartype(luErrWorkArea) = 'N' and ;
					between(luErrWorkArea, 1, 32767)
					lcCursor = alias(luErrWorkArea)
				otherwise
					lcCursor = transform(luErrWorkArea)
			endcase
			lcSource = iif(empty(lcErrSource), '', lcErrSource)
			do case
				case lnErrNumber <> cnERR_TRIGGER_FAILED or ;
					isnull(luErrTrigger) or empty(luErrTrigger)
					lcTrigger = ''
				case luErrTrigger = 1
					lcTrigger = 'Insert'
				case luErrTrigger = 2
					lcTrigger = 'Update'
				otherwise
					lcTrigger = 'Delete'
			endcase
			lcOther1 = iif(isnull(luErrExtra1) or empty(luErrExtra1) or ;
				vartype(luErrExtra1) <> 'C', '', luErrExtra1)
			lcOther2 = iif(isnull(luErrExtra2) or empty(luErrExtra2) or ;
				vartype(luErrExtra2) <> 'C', '', luErrExtra2)
		
		* Get a list of variables and their values.
		
			lcVars = .GetMemVars()
		
		* We're logging to a table, so grab the alias of the table first. If the file
		* whose name is in This.cErrorLogFile exists, open it. Otherwise, create it.
		
			if .lLogToTable
				lcAlias      = sys(2015)
				lnCurrSelect = select()
				try
					if not file(.cErrorLogFile) or ;
						not file(forceext(.cErrorLogFile, 'FPT'))
						create table (lower(.cErrorLogFile)) free ;
							(DATETIME T, ;
							USER C(40), ;
							MACHINE C(40), ;
							APPNAME C(40), ;
							VERSION C(15), ;
							ERR_NUM I, ;
							MESSAGE C(128), ;
							LINE I, ;
							METHOD C(128), ;
							SOURCE C(128), ;
							ALIAS C(128), ;
							TRIGGER C(6), ;
							OTHER1 C(128), ;
							OTHER2 C(128), ;
							MEMVARS M)
						use
						select (lnCurrSelect)
					endif not file(.cErrorLogFile) ...
					if file(.cErrorLogFile)
						use (.cErrorLogFile) alias (lcAlias) again shared in 0
					endif file(.cErrorLogFile)
				catch
				endtry
		
		* If we successfully opened or created the file, log the error to it.
		
				if used(lcAlias) and not isreadonly(lcAlias)
					insert into (lcAlias) ;
							(DATETIME, ;
							USER, ;
							ERR_NUM, ;
							MESSAGE, ;
							LINE, ;
							METHOD, ;
							SOURCE, ;
							ALIAS, ;
							TRIGGER, ;
							OTHER1, ;
							OTHER2, ;
							MEMVARS) ;
						values ;
							(ltErrTime, ;
							lcErrUser, ;
							lnErrNumber, ;
							lcErrMessage, ;
							lnErrLine, ;
							lcErrMethod, ;
							lcSource, ;
							lcCursor, ;
							lcTrigger, ;
							lcOther1, ;
							lcOther2, ;
							'')
					select (lcAlias)
					replace MEMVARS with lcVars
					if type('MACHINE') <> 'U'
						replace MACHINE with lcErrMachine
					endif type('MACHINE') <> 'U'
					if type('APPNAME') <> 'U'
						replace APPNAME with .cAppName
					endif type('APPNAME') <> 'U'
					if type('VERSION') <> 'U'
						replace VERSION with .cVersion
					endif type('VERSION') <> 'U'
					select (lnCurrSelect)
					use in (lcAlias)
				endif used(lcAlias) ...
			endif .lLogToTable
		
		* Log to a text file used as an attachment for a support ticket or email.
		
			.cErrorLogTextFile = addbs(sys(2023)) + sys(3) + '.txt'
			lnHandle = fcreate(.cErrorLogTextFile)
			if lnHandle >= 0
				fseek(lnHandle, 0, 2)
				fwrite(lnHandle, ccMSG_ERROR_NUM + transform(lnErrNumber) + ccCRLF)
				fwrite(lnHandle, ccMSG_MESSAGE + lcErrMessage + ccCRLF)
				if lnErrLine <> 0
					fwrite(lnHandle, ccMSG_LINE_NUM + transform(lnErrLine) + ;
						ccCRLF)
				endif lnErrLine <> 0
				fwrite(lnHandle, ccMSG_METHOD + lcErrMethod + ccCRLF)
				if not isnull(lcErrObject) and not empty(lcErrObject) and ;
					not lcErrObject $ lcErrMessage
					fwrite(lnHandle, ccMSG_OBJECT + lcErrObject + ccCRLF)
				endif not isnull(lcErrObject) ...
				if not empty(lcSource)
					fwrite(lnHandle, ccMSG_CODE + lcSource + ccCRLF)
				endif not empty(lcSource)
				do case
					case isnull(luErrWorkArea) or empty(luErrWorkArea)
					case vartype(luErrWorkArea) = 'N' and ;
						between(luErrWorkArea, 1, 32767)
						fwrite(lnHandle, ccMSG_WORKAREA + ;
							transform(luErrWorkArea) + ccCRLF)
					otherwise
						fwrite(lnHandle, ccMSG_OLESERVER + luErrWorkArea + ccCRLF)
				endcase
				fwrite(lnHandle, ccMSG_ALIAS + lcCursor + ccCRLF)
				do case
					case isnull(luErrTrigger) or empty(luErrTrigger)
					case vartype(luErrTrigger) = 'N'
						fwrite(lnHandle, ccMSG_TRIGGER + ;
							transform(luErrTrigger) + ccCRLF)
					otherwise
						fwrite(lnHandle, ccMSG_TRIGGER + luErrTrigger + ccCRLF)
				endcase
				if not empty(lcOther1)
					fwrite(lnHandle, ccMSG_OTHER_INFO + lcOther1 + ccCRLF)
				endif not empty(lcOther1)
				if not empty(lcOther2)
					fwrite(lnHandle, ccMSG_OTHER_INFO + lcOther2 + ccCRLF)
				endif not empty(lcOther2)
				fwrite(lnHandle, ccMSG_DATETIME + ttoc(ltErrTime) + ccCRLF)
				fwrite(lnHandle, ccMSG_USER + lcErrUser + ccCRLF)
				fwrite(lnHandle, ccMSG_MACHINE + lcErrMachine + ccCRLF)
				fwrite(lnHandle, ccCRLF)
				fwrite(lnHandle, lcVars)
				fclose(lnHandle)
			endif lnHandle >= 0
		
		* Reset the error info saved flag and restore SAFETY.
		
			.lErrorInfoSaved = .F.
			if lcSafety = 'ON'
				set safety on
			endif lcSafety = 'ON'
		endwith
		
	ENDPROC

	PROCEDURE reseterror		&& An exposed method to reset the values of the protected lErrorOccurred and public aErrorInfo.
		*==============================================================================
		* Method:			ResetError
		* Status:			Public
		* Purpose:			Resets the error flag and array (an exposed method to
		*						handle these protected properties)
		* Author:			Doug Hennig
		* Last revision:	03/18/2021
		* Parameters:		None
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	This.lErrorOccurred and lErrorInfoSaved are set to .F.
		*					This.aErrorInfo is redimensioned and blanked
		*==============================================================================
		
		with This
			.lErrorOccurred  = .F.
			.lErrorInfoSaved = .F.
			dimension .aErrorInfo[cnAERR_MAX]
			.aErrorInfo = ''
		endwith
		
	ENDPROC

	PROCEDURE revertalltables		&& Reverts all cursors in all datasessions
		*==============================================================================
		* Method:			RevertAllTables
		* Status:			Protected
		* Purpose:			Revert all cursors in all datasessions
		* Author:			Doug Hennig
		* Last revision:	08/24/2005
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	all cursors in all datasessions are reverted
		*==============================================================================
		
		local laSessions[1], ;
			lnSessions, ;
			lnI
		lnSessions = asessions(laSessions)
		for lnI = lnSessions to 1 step -1
			set datasession to laSessions[lnI]
			This.RevertTables()
		next lnI
		set datasession to 1
		
	ENDPROC

	PROCEDURE reverttables		&& Revert cursors in the current datasession
		*==============================================================================
		* Method:			RevertTables
		* Status:			Protected
		* Purpose:			Revert cursors in the current datasession
		* Author:			Doug Hennig
		* Last Revision:	09/15/2005
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	the datasession to revert tables in is the current one
		* Environment out:	all transactions have been rolled back and tables reverted
		*==============================================================================
		
		local laCursors[1], ;
			lnCursors, ;
			lnI, ;
			lcAlias
		
		* Rollback all transactions.
		
		try
			do while txnlevel() > 0
				rollback
			enddo while txnlevel() > 0
		catch
		endtry
		
		* Revert all changes in all buffered tables.
		
		lnCursors = aused(laCursors)
		for lnI = 1 to lnCursors
			lcAlias = laCursors[lnI, 1]
			if cursorgetprop('Buffering', lcAlias) > 1
				try
					tablerevert(.T., lcAlias)
				catch
				endtry
			endif cursorgetprop('Buffering', lcAlias) > 1
		next lnI
		return
		
	ENDPROC

	PROCEDURE screenshot		&& Takes a screen shot
		*==============================================================================
		* Method:			ScreenShot
		* Status:			Public
		* Purpose:			Takes a screen shot
		* Author:			Doug Hennig
		* Last Revision:	04/05/2022
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	System.app or exe must be available
		* Environment out:	a screen shot was taken to a temporary file whose name and
		*						path is in This.cImageFile
		*==============================================================================
		
		local loCaptureBmp
		do System
		This.cImageFile = addbs(sys(2023)) + sys(2015) + '.jpg'
		with _screen.System.Drawing
			try
				loCaptureBmp = .Bitmap.FromScreen(_vfp.hWnd)
				loCaptureBmp.Save(This.cImageFile, .Imaging.ImageFormat.JPEG)
			catch
			endtry
		endwith
		
	ENDPROC

	PROCEDURE setdialogproperties		&& Sets properties of the error dialog before displaying it
		*==============================================================================
		* Function:			SetDialogProperties
		* Status:			Public
		* Purpose:			Sets properties of the error dialog before displaying it
		* Author:			Doug Hennig
		* Last revision:	03/12/2021
		* Parameters:		toDialog - a reference to the dialog
		* Returns:			none
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		* Abstract method.
		
		lparameters toDialog
		
	ENDPROC

	PROCEDURE seterror		&& Sets lErrorOccurred and aErrorInfo to information about the most recent error
		*==============================================================================
		* Method:			SetError
		* Status:			Public
		* Purpose:			Sets lErrorOccurred and aErrorInfo to information about
		*						the most recent error
		* Author:			Doug Hennig
		* Last revision:	07/14/2022
		* Parameters:		tcMethod - the method or function the error occurred in
		*					tnLine   - the line number within tcMethod
		*					tcSource - the code causing the error
		*					tuError  - an array of error information, an Exception
		*						object, or a message to log (optional: only needed if
		*						we're logging a real error)
		* Returns:			.T.
		* Environment in:	This.aErrorInfo is dimensioned appropriately
		*					This.lErrorSet is .T. if this method has already been called
		*						for this error
		*					This.nMaxErrors contains the maximum number of errors to
		*						keep in This.aErrorInfo (0 = no limit)
		* Environment out:	This.lErrorOccurred is .T.
		*					This.lErrorInfoSaved is .T.
		*					This.nLastError points to the current row in
		*						This.aErrorInfo
		*					This.aErrorInfo is filled with error information as
		*						follows:
		*
		*					Column	Information
		*					------	-----------
		*					1 - 7	same as AERROR()
		*					8		method error occurred in
		*					9		line error occurred on
		*					10		code causing error
		*					11		date/time error occurred
		*					12		name of the user
		*					13		machine information
		*==============================================================================
		
		lparameters tcMethod, ;
			tnLine, ;
			tcSource, ;
			tuError
		local lcType, ;
			llException, ;
			lnRows, ;
			lnCols, ;
			llMessage, ;
			lnLast, ;
			lnError, ;
			lnRow, ;
			lnI
		external array tuError
		with This
		
		* If we've already been called, just update the method information.
		
			if .lErrorInfoSaved
				.aErrorInfo[.nLastError, cnAERR_METHOD] = tcMethod
			else
		
		* Flag that an error occurred.
		
				.lErrorOccurred  = .T.
				.lErrorInfoSaved = .T.
				lcType           = type('tuError', 1)
				lcType           = iif(lcType = 'U', type('tuError'), lcType)
				llException      = lcType = 'O'
				do case
					 case llException
						lnRows = 1
						lnCols = 1
					case lcType = 'A'
						lnRows = alen(tuError, 1)
						lnCols = alen(tuError, 2)
					otherwise
						lnCols    = 0
						lnRows    = 0
						llMessage = lcType = 'C'
				endcase
		
		* If we're past the maximum size of the array, delete a row. Otherwise, set the
		* next row number.
		
				lnLast = iif(empty(.aErrorInfo[1, 1]), 0, alen(.aErrorInfo, 1))
				if .nMaxErrors > 0 and lnLast >= .nMaxErrors
					adel(.aErrorInfo, 1)
					lnLast = lnLast - 1
				endif .nMaxErrors > 0 ...
		
		* If we have a 1-D array, no real error occurred (we were just called to log
		* an error), so adjust the loop values we'll use.
		
				if lnCols = 0
					lnCols = lnRows
					lnRows = 1
				endif lnCols = 0
		
		* For each row in the error array, put each column into our array.
		
				dimension .aErrorInfo[lnLast + lnRows, cnAERR_MAX]
				for lnError = 1 to lnRows
					lnRow = lnLast + lnError
					do case
		
		* We have an Exception object, so fill the array with its properties.
		
						case llException
							.aErrorInfo[lnRow, cnAERR_NUMBER]  = tuError.ErrorNo
							.aErrorInfo[lnRow, cnAERR_MESSAGE] = tuError.Message
							.aErrorInfo[lnRow, cnAERR_OBJECT]  = tuError.Details
		
		* We have a normal error array, so put each column into our array.
		
						case lnCols > 1
							for lnI = 1 to lnCols
								.aErrorInfo[lnRow, lnI] = tuError[lnError, lnI]
							next lnI
		
		* No real error occurred (we were just called to log an error), so defaults
		* into our array.
		
						otherwise
							.aErrorInfo[lnRow, cnAERR_NUMBER]  = 0
							.aErrorInfo[lnRow, cnAERR_MESSAGE] = iif(llMessage, ;
								tuError, '')
					endcase
		
		* Add some additional information to the current row in our array.
		
					.aErrorInfo[lnRow, cnAERR_METHOD]   = tcMethod
					.aErrorInfo[lnRow, cnAERR_LINE]     = tnLine
					.aErrorInfo[lnRow, cnAERR_SOURCE]   = ;
						iif(tcSource = .aErrorInfo[lnRow, cnAERR_MESSAGE] or ;
						version(2) = 0, '', tcSource)
					.aErrorInfo[lnRow, cnAERR_DATETIME] = datetime()
					.aErrorInfo[lnRow, cnAERR_USER]     = .cUser
					.aErrorInfo[lnRow, cnAERR_MACHINE]  = sys(0)
				next lnError
				.nLastError = alen(.aErrorInfo, 1)
			endif not .lErrorInfoSaved
		endwith
		return
		
	ENDPROC

	PROCEDURE setsuppresserrors		&& An exposed method to set the value of the protected lSuppressErrors.
		*==============================================================================
		* Function:			SetSuppressErrors
		* Status:			Public
		* Purpose:			Sets This.lSuppressErrors and returns its former value (an
		*						exposed method to handle this protected property)
		* Author:			Doug Hennig
		* Last revision:	09/30/2003
		* Parameters:		tlSuppress - .T. to suppress errors or .F. to show them
		* Returns:			the former value of This.lSuppressErrors
		* Environment in:	none
		* Environment out:	This.lSuppressErrors is set as desired as long as the
		*						passed value is logical and not null. Otherwise, it
		*						isn't changed
		*==============================================================================
		
		lparameters tlSuppress
		local llSuppress
		with This
			llSuppress       = .lSuppressErrors
			.lSuppressErrors = iif(vartype(tlSuppress) = 'L', tlSuppress, ;
				.lSuppressErrors)
		endwith
		return llSuppress
		
	ENDPROC

ENDDEFINE
